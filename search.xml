<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/11/10/git/"/>
      <url>/2023/11/10/git/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: git</span><br><span class="line">description: git</span><br><span class="line">date: 2023-11-10 15:59:00</span><br><span class="line">update: 2023-11-10 15:59:00</span><br><span class="line">tags:</span><br><span class="line">  - 计算机</span><br><span class="line">categories:</span><br><span class="line">  - git</span><br><span class="line">swiper_index: 15</span><br></pre></td></tr></table></figure><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户邮箱</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog或者git log</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: 操作系统</span><br><span class="line">description: 操作系统</span><br><span class="line">date: 2023-10-28 11:45:00</span><br><span class="line">update: 2023-10-28 11:45:00</span><br><span class="line">tags:</span><br><span class="line">  - 课程</span><br><span class="line">categories:</span><br><span class="line">  - 操作系统</span><br><span class="line">swiper_index: 16</span><br></pre></td></tr></table></figure><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h3><p>程序执行过程中通常存在顺序执行问题</p><ul><li>构成程序的若干个程序段之间</li><li>组成程序段的多条语句之间</li></ul><h4 id="程序顺序执行时的特征"><a href="#程序顺序执行时的特征" class="headerlink" title="程序顺序执行时的特征"></a>程序顺序执行时的特征</h4><ol><li><p>顺序性</p><p>处理机的操作，严格按照规定顺序执行</p></li><li><p>封闭性</p><ul><li>封闭环境下运行，程序独占全机资源</li><li>只有当前运行程序才能改变资源状态</li><li>程序执行结果不受外界因素的影响</li></ul></li><li><p>可再现性</p><p>只要程序执行时的环境和初始条件相同，程序重复执行结果相同</p></li></ol><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>在一段时间里，多道程序一起共享计算机系统的资源，一起操作向前推进</p><h4 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h4><ol><li><p>间断性</p><p>”执行一暂停执行—执行”的活动规律</p></li><li><p>失去封闭性</p><p>系统资源共享及资源状态改变的多样性，致使程序运行失去封闭性，程序运行必然会受到其它程序的影响</p></li><li><p>不可再现性</p><p>并发执行的程序，计算结果与其执行速度及时间有关</p></li></ol><h3 id="进程的定义及特征"><a href="#进程的定义及特征" class="headerlink" title="进程的定义及特征"></a>进程的定义及特征</h3><h4 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h4><ul><li>并发、共享及多道程序环境</li><li>基于程序的概念已不能完整、有效地描述并发程序在内存中的运行状态</li><li>必须建立并发程序的新的描述和控制机制</li><li>基于程序段、数据段和进程控制块而引入进程的概念以对应程序的运行过程</li><li>进程控制块存放了进程标识符、进程运行的当前状态、程序和数据的地址以及关于该程序运行时的CPU环境信息</li></ul><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol><li>进程是可并发执行的程序在一个数据集合上的运行过程，亦即进程实体的运行过程<br><strong>进程实体由程序段、数据段及进程控制块三部分构成</strong></li><li>进程是系统进行资源分配和调度的一个独立单位</li></ol><h4 id="进程的特征—-与程序的区别与联系"><a href="#进程的特征—-与程序的区别与联系" class="headerlink" title="进程的特征—-与程序的区别与联系"></a>进程的特征—-与程序的区别与联系</h4><ol><li><p>结构特征</p><p>程序段、数据段及进程控制块</p></li><li><p>动态性</p><p>生命周期及“执行”本质</p></li><li><p>并发性</p><p>共存于内存、宏观同时运行</p></li><li><p>独立性</p><p>调度、资源分配、运行</p></li><li><p>异步性</p><p>推进相互独立、速度不可预知</p></li></ol><h3 id="进程并发制约关系及临界区"><a href="#进程并发制约关系及临界区" class="headerlink" title="进程并发制约关系及临界区"></a>进程并发制约关系及临界区</h3><h4 id="并发进程间制约关系"><a href="#并发进程间制约关系" class="headerlink" title="并发进程间制约关系"></a>并发进程间制约关系</h4><p>资源共享关系—-间接制约</p><ul><li>多个进程彼此无关，完全不知道或只能间接感知其它进程的存在</li><li>系统须保证诸进程能互斥地访问临界资源</li><li>系统资源应统一分配，而不允许用户进程直接用</li></ul><p>相互合作关系—-直接制约<br>系统应保证相互合作的诸进程在执行次序上的协调和防止与时间有关的差错</p><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>一段时间内只允许一个进程访问的资源。如 许多物理设备、变量及表格</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>每个进程中访问临界资源的那段代码称为临界区<br>保证诸进程互斥地进入自己的临界区是实现它们对临界资源的互斥访问的充要条件（同一个临界资源）</p><h3 id="进程同步机制基本准则"><a href="#进程同步机制基本准则" class="headerlink" title="进程同步机制基本准则"></a>进程同步机制基本准则</h3><ol><li><p>空闲让进</p><p>当无进程处于临界区时，可允许一个请求进入临界区的进程立即进入自己的临界区</p></li><li><p>忙则等待</p><p>当已有进程进入自己的临界区时，所有企图进入临界区的进程必须等待</p></li><li><p>有限等待</p><p>对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区</p></li><li><p>让权等待</p><p>当进程不能进入自己的临界区时，应释放处理机</p></li></ol><h3 id="进程互斥访问临界资源的软件解决方案"><a href="#进程互斥访问临界资源的软件解决方案" class="headerlink" title="进程互斥访问临界资源的软件解决方案"></a>进程互斥访问临界资源的软件解决方案</h3><h4 id="进程互斥算法1-设置访问编号"><a href="#进程互斥算法1-设置访问编号" class="headerlink" title="进程互斥算法1-设置访问编号"></a>进程互斥算法1-设置访问编号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var turn：integer：=i；[全局变量]</span><br><span class="line"></span><br><span class="line">Pi：while turn!=i</span><br><span class="line"></span><br><span class="line">do no_op;</span><br><span class="line"></span><br><span class="line">临界区</span><br><span class="line"></span><br><span class="line">turn:=j;</span><br></pre></td></tr></table></figure><p>强制设置进程访问，违背了空闲让进</p><p>进不了临界区也没有让出处理器资源，违背了让权等待</p><h4 id="进程互斥算法2-设置访问标志"><a href="#进程互斥算法2-设置访问标志" class="headerlink" title="进程互斥算法2-设置访问标志"></a>进程互斥算法2-设置访问标志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量]</span><br><span class="line"></span><br><span class="line">Pi：while flagj</span><br><span class="line"></span><br><span class="line">do no_op;</span><br><span class="line"></span><br><span class="line">flagi:=true;</span><br><span class="line"></span><br><span class="line">临界区</span><br><span class="line"></span><br><span class="line">flagi:=false;</span><br></pre></td></tr></table></figure><p>违背了忙则等待和让权等待</p><h4 id="进程互斥算法3-设置欲访问标志"><a href="#进程互斥算法3-设置欲访问标志" class="headerlink" title="进程互斥算法3-设置欲访问标志"></a>进程互斥算法3-设置欲访问标志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量] </span><br><span class="line"></span><br><span class="line">Pi：flagi:=true;</span><br><span class="line"></span><br><span class="line">while flagj</span><br><span class="line"></span><br><span class="line">do no_op;</span><br><span class="line"></span><br><span class="line">临界区</span><br><span class="line"></span><br><span class="line">flagi:=false;</span><br></pre></td></tr></table></figure><p>违背了空闲让进、有限等待和让权等待</p><h4 id="进程互斥算法4-编号-标志（Peterson算法）"><a href="#进程互斥算法4-编号-标志（Peterson算法）" class="headerlink" title="进程互斥算法4-编号+标志（Peterson算法）"></a>进程互斥算法4-编号+标志（Peterson算法）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量] </span><br><span class="line"></span><br><span class="line">turn：integer；</span><br><span class="line"></span><br><span class="line">Pi：flagi：=true；trun:=j;</span><br><span class="line"></span><br><span class="line">while(flagj and turn==j)</span><br><span class="line"></span><br><span class="line">do no_op;</span><br><span class="line"></span><br><span class="line">临界区</span><br><span class="line"></span><br><span class="line">flagi:=false;</span><br></pre></td></tr></table></figure><p>违背了让权等待</p><h3 id="整型信号量机制"><a href="#整型信号量机制" class="headerlink" title="整型信号量机制"></a>整型信号量机制</h3><p>整型信号量s（计算机资源可用的数量）除初始化外，仅能被两个标准的原子操作wait(s)和signal(s)亦即P&#x2F;V操作来访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(s)：while s&lt;=0 do no_op;</span><br><span class="line">    s:=s-1;</span><br><span class="line">signal(s):s:=s+1;</span><br></pre></td></tr></table></figure><p>违背了让权等待</p><h3 id="记录型信号量机制"><a href="#记录型信号量机制" class="headerlink" title="记录型信号量机制"></a>记录型信号量机制</h3><h4 id="信号量类型声明"><a href="#信号量类型声明" class="headerlink" title="信号量类型声明"></a>信号量类型声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type semphore=record//信号量</span><br><span class="line">value:integer;//&gt;=0表示对该信号量的可用资源数量，&lt;=0其绝对值表示阻塞队列的长度，即有多少个进程正在等待资源</span><br><span class="line">L:list of process;//当前等待使用资源的进程列表或者队列</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="wait（s）操作描述"><a href="#wait（s）操作描述" class="headerlink" title="wait（s）操作描述"></a>wait（s）操作描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure wait(s)</span><br><span class="line">Var s:semphore;</span><br><span class="line">begin</span><br><span class="line">s.value:=s.value -1;</span><br><span class="line">if s.value&lt;0 then block(s.L);//&lt;0表示已经没有资源了，无资源则将该进程挂到阻塞队列</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="signal（s）操作描述"><a href="#signal（s）操作描述" class="headerlink" title="signal（s）操作描述"></a>signal（s）操作描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure signal(s)</span><br><span class="line">Var s:semphore;</span><br><span class="line">begin</span><br><span class="line">s.value:=s.value 1;</span><br><span class="line">if s.value&lt;=0 then wakeup(s.L);//=0表示阻塞队列长度为|-1|，则需要唤醒被阻塞进程</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="AND型信号量集机制"><a href="#AND型信号量集机制" class="headerlink" title="AND型信号量集机制"></a>AND型信号量集机制</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>对于多个进程要共享两个以上的资源的情况，记录型信号量机制侧可能由于使用不当而导致死锁的发生</p><p><strong>对于临界资源的互斥信号量的初始值为1</strong></p><h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><p>若干个临界资源的分配采取原子操作方式</p><h4 id="Swait（s1，s2，…，sn）操作"><a href="#Swait（s1，s2，…，sn）操作" class="headerlink" title="Swait（s1，s2，…，sn）操作"></a>Swait（s1，s2，…，sn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure Swait(s1,s2,...sn)</span><br><span class="line">Var s1,s2,...,sn:semphore;</span><br><span class="line">begin</span><br><span class="line">if s1.value≥1 and..and s.value≥1</span><br><span class="line">then for i:=1 to n do</span><br><span class="line">si.value:=s .value -1;</span><br><span class="line">else blockProcessAndResetPC(sfirstless);//挂到第一个不能满足的信号量阻塞队列上，资源重新做申请操作</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Swait详细"><a href="#Swait详细" class="headerlink" title="Swait详细"></a>Swait详细</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">    Var zSbG:boolean:=false;</span><br><span class="line">    for i:=1 to n do</span><br><span class="line">    &#123;if (si.value &lt;1)</span><br><span class="line">    &#123;zSbG:=true;break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zSbG)</span><br><span class="line">    &#123;ResetPC();</span><br><span class="line">    block(si.L);&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;for i:=1 to n do</span><br><span class="line">    si.value:=si.value -1;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Ssignal（s1，s2，…，sn）操作"><a href="#Ssignal（s1，s2，…，sn）操作" class="headerlink" title="Ssignal（s1，s2，…，sn）操作"></a>Ssignal（s1，s2，…，sn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure Ssignal(s1,s2,...,sn)</span><br><span class="line">Var s1,s2,...,sn semphore;</span><br><span class="line">begin</span><br><span class="line">for i:=1 to n do</span><br><span class="line">si.value:=si.value＋1;</span><br><span class="line">wakeup(si.L);</span><br><span class="line">endfor;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="一般信号量集机制"><a href="#一般信号量集机制" class="headerlink" title="一般信号量集机制"></a>一般信号量集机制</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><ul><li>记录型信号量及AND信号量集机制中，wait(s)和signal(s)操作仅能对信号量施以增1和减1的操作，即每次只能获得或释放一个单位的临界资源。当一次需d个某类临界资源时，便需要进行d次wait(s)操作，这显然是低效的。</li><li>此外，在有些情况下，要求当资源数量低于某一下限值时，便不予分配。故在每次分配之前，都必须测试该资源的数量是否不小于测试值t。</li><li>基于以上两点可以对AND信号量集机制进行扩充，形成一般化的“信号量集”机制。</li></ul><h4 id="Swait（s1，t1，d1，…，sn，tn，dn）操作"><a href="#Swait（s1，t1，d1，…，sn，tn，dn）操作" class="headerlink" title="Swait（s1，t1，d1，…，sn，tn，dn）操作"></a>Swait（s1，t1，d1，…，sn，tn，dn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure Swait(s1,t1,d1,...,sn,tn,dn)</span><br><span class="line">Var s1,s2,...,sn:semphore;//信号量</span><br><span class="line">t,t2,…,tnd,d2,…,dn:integer;//d为申请多少资源，t为下限值</span><br><span class="line">begin</span><br><span class="line">ifs.value≥tand.…and sn.value≥tn</span><br><span class="line">then for i:=1 to n do</span><br><span class="line">si.value:=si.value -di;</span><br><span class="line">else blockProcessAndResetPC(sfirstless);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Swait详细-1"><a href="#Swait详细-1" class="headerlink" title="Swait详细"></a>Swait详细</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">Var zSbG:boolean:=false;</span><br><span class="line">for i:=1 to n do</span><br><span class="line">&#123;if (si.value &lt;t</span><br><span class="line">&#123;zSbG:=true;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (zSbG)</span><br><span class="line">&#123;ResetPC();</span><br><span class="line">block(si.L);&#125;</span><br><span class="line">else</span><br><span class="line">&#123;for i:=1 to n do</span><br><span class="line">si.value:=si.value di;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Ssignal（s1，d1，…，sn，dn）操作"><a href="#Ssignal（s1，d1，…，sn，dn）操作" class="headerlink" title="Ssignal（s1，d1，…，sn，dn）操作"></a>Ssignal（s1，d1，…，sn，dn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure Ssignal(s1,d1,...sn,dn)</span><br><span class="line">Var s1,s2,...,s:semphore;</span><br><span class="line">d1,d2,…,dn:integer;,</span><br><span class="line">begin</span><br><span class="line">for i:=1 to n do</span><br><span class="line">si.value:=si.value d;</span><br><span class="line">wakeup(si.L);</span><br><span class="line">endfor;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="一般信号量集的几种特殊情况"><a href="#一般信号量集的几种特殊情况" class="headerlink" title="一般信号量集的几种特殊情况"></a>一般信号量集的几种特殊情况</h4><h5 id="Swait-s-d-d"><a href="#Swait-s-d-d" class="headerlink" title="Swait(s,d,d)"></a>Swait(s,d,d)</h5><p>信号量集中只有一个信号量，但它允许每次申请d个资源；当现有资源少于d个时，便不予分配</p><h5 id="Swait-s-1-1"><a href="#Swait-s-1-1" class="headerlink" title="Swait(s,1,1)"></a>Swait(s,1,1)</h5><p>此时的信号量集已退化为一般的记录型信号量</p><h5 id="Swait-s-1-0"><a href="#Swait-s-1-0" class="headerlink" title="Swait(s,1,0)"></a>Swait(s,1,0)</h5><ul><li>一种特殊且很有用的信号量，相当于可控开关</li><li>当s≥1时，允许多个进程进入某特定区；当s变为0后，将阻止任何进程进入该特定区</li></ul><h3 id="基于信号量机制解决进程并发问题的应用基础"><a href="#基于信号量机制解决进程并发问题的应用基础" class="headerlink" title="基于信号量机制解决进程并发问题的应用基础"></a>基于信号量机制解决进程并发问题的应用基础</h3><h4 id="利用信号量实现互斥—-主程序"><a href="#利用信号量实现互斥—-主程序" class="headerlink" title="利用信号量实现互斥—-主程序"></a>利用信号量实现互斥—-主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Var mutex:semphore:=1;//互斥信号量，且初始值必须为1</span><br><span class="line">begin</span><br><span class="line">parbegin//表示process1和process2可以并发执行</span><br><span class="line">processl;</span><br><span class="line">process2;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="利用信号量实现互斥—-子程序"><a href="#利用信号量实现互斥—-子程序" class="headerlink" title="利用信号量实现互斥—-子程序"></a>利用信号量实现互斥—-子程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process1:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(mutex);</span><br><span class="line">临界区</span><br><span class="line">signal(mutex);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><ol><li><p>生产者一消费者问题是相互合作进程关系的一种抽象</p><ul><li>输入时的输入进程与计算进程</li><li>输出时的计算进程与输出进程</li></ul></li><li><p>生产者一消费者问题具有很大的代表性和实用价值</p><p>计算机系统一IPO系统</p></li></ol><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>一群生产者进程在生产数据，并将此数据提供给一群消费者进程去消费处理</li><li>为使二者可以并发执行，在它们之间设置了一个具有n个缓冲区的循环缓冲，生产者进程可以将它所生产的数据放入一个缓冲区中，消费者进程可以从一个缓冲区中取得一个数据消费</li><li>异步运行方式及彼此必须保持同步</li></ul><h4 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h4><h5 id="空缓冲区和满缓冲区"><a href="#空缓冲区和满缓冲区" class="headerlink" title="空缓冲区和满缓冲区"></a>空缓冲区和满缓冲区</h5><ul><li>空缓冲区是指未投放数据或虽曾投放数据但对应数据已被取走的缓冲区</li><li>满缓冲区则指已投放数据且对应数据尚未被取走的缓冲区</li></ul><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><ul><li>当生产者进程要把所生产的数据送入循环缓冲时，首先应检查是否有空缓冲区存在，若有，则可向对应空缓冲区中投放数据，同时通知逍费者进程；否则只有等待。</li><li>当消费者进程要从循环缓冲中提取数据时，首先应检查是否有满缓冲区存在，若有，则从对应满缓冲区中提取数据，并通知生产者进程，否则只有等待</li></ul><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>缓冲区及其“指针”是临界资源：多个生产者&#x2F;消费者进程</p><h4 id="程序变量设计"><a href="#程序变量设计" class="headerlink" title="程序变量设计"></a>程序变量设计</h4><h5 id="循环缓冲表示机制"><a href="#循环缓冲表示机制" class="headerlink" title="循环缓冲表示机制"></a>循环缓冲表示机制</h5><p>一维数组ouffer::array[0.n-l]of item;</p><h5 id="输入指针in"><a href="#输入指针in" class="headerlink" title="输入指针in"></a>输入指针in</h5><ul><li>指示下一个可以投放数据的缓冲区</li><li>初始值为0；变化方式：in:&#x3D;(in+1) mod n</li></ul><h5 id="输出指针out"><a href="#输出指针out" class="headerlink" title="输出指针out"></a>输出指针out</h5><ul><li>指示下一个可以获取数据的缓冲区</li><li>初始值为0；变化方式：out:&#x3D;(out+1) mod n</li></ul><h5 id="暂存数据"><a href="#暂存数据" class="headerlink" title="暂存数据"></a>暂存数据</h5><p>nextp&#x2F;nextc暂存每次要生产或消费的数据</p><h4 id="程序信号量的设计"><a href="#程序信号量的设计" class="headerlink" title="程序信号量的设计"></a>程序信号量的设计</h4><h5 id="循环缓冲（缓冲区及其指针）的互斥使用"><a href="#循环缓冲（缓冲区及其指针）的互斥使用" class="headerlink" title="循环缓冲（缓冲区及其指针）的互斥使用"></a>循环缓冲（缓冲区及其指针）的互斥使用</h5><p>互斥信号量mutex,初始值为1</p><h5 id="资源信号量"><a href="#资源信号量" class="headerlink" title="资源信号量"></a>资源信号量</h5><ul><li>empty表示循环缓冲中的空缓冲区的数量其初始值为n</li><li>full表示循环缓冲中的满缓冲区的数量，其初始值为0</li></ul><h4 id="主程序设计"><a href="#主程序设计" class="headerlink" title="主程序设计"></a>主程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var buffer:array [0..n-1]of item;//循环缓冲</span><br><span class="line">in,out:integer :0,0;//输入输出指针</span><br><span class="line">mutex,empty,full semphore :=1,n,0</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">producer1;..produceri;...producerY;</span><br><span class="line">consumer1;..consumerj;...;consumerX；</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="生产者子程序设计"><a href="#生产者子程序设计" class="headerlink" title="生产者子程序设计"></a>生产者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">produceri;:</span><br><span class="line">Var nextp:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">produce an item in nextp;</span><br><span class="line">wait(empty);</span><br><span class="line">wait(mutex);</span><br><span class="line">buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">signal(mutex);</span><br><span class="line">signal(full);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="消费者子程序设计"><a href="#消费者子程序设计" class="headerlink" title="消费者子程序设计"></a>消费者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">nextc:=buffer[out];out:=(out+1)mod n</span><br><span class="line">signal(mutex);</span><br><span class="line">signal(empty);</span><br><span class="line">consume.the item in nextc;</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="初步解决方案的反思"><a href="#初步解决方案的反思" class="headerlink" title="初步解决方案的反思"></a>初步解决方案的反思</h4><h5 id="关于相邻wait（signal）操作颠倒的分析"><a href="#关于相邻wait（signal）操作颠倒的分析" class="headerlink" title="关于相邻wait（signal）操作颠倒的分析"></a>关于相邻wait（signal）操作颠倒的分析</h5><p>在生产者一消费者问题中，如果将两个wait操作即wait(full)和wait(nutex)互换位置；或者是将signal((mutex)与signal(full)互换位置，结果会如何？</p><ol><li><p>wait(full)和wait(mutex)互换位置</p><ul><li><p>消费者wait(mutex)&#x3D;&gt;wait(full)</p></li><li><p>生产者wait(empty)&#x3D;&gt;wait(mutex)</p></li><li><p>时间节点：循环缓冲均为空缓冲区时</p></li><li><p>陷入死锁</p></li></ul></li><li><p>signal(mutex)与signal(full)互换位置</p><p>没有影响</p></li></ol><h5 id="关于signal操作缺失的分析"><a href="#关于signal操作缺失的分析" class="headerlink" title="关于signal操作缺失的分析"></a>关于signal操作缺失的分析</h5><p>在生产者一消费者问题中，如果缺少了signal(full)或signal(empty),对执行结果会有何影响？</p><ol><li>缺少了signal（full）<ul><li>生产者：开始—&gt;生产者生产数据填满n个缓冲区时—-&gt;陷入死锁</li><li>消费者：等待full信号量—-&gt;陷入死锁</li></ul></li><li>缺少了signal（empty）<ul><li>生产者：等待empty信号量—-&gt;陷入死锁</li><li>消费者：开始—-&gt;消费者取走了n个缓冲区数据时—-&gt;陷入死锁</li></ul></li></ol><h4 id="基于AND信号量的生产-x2F-消费者子程序设计"><a href="#基于AND信号量的生产-x2F-消费者子程序设计" class="headerlink" title="基于AND信号量的生产&#x2F;消费者子程序设计"></a>基于AND信号量的生产&#x2F;消费者子程序设计</h4><h5 id="生产者子程序"><a href="#生产者子程序" class="headerlink" title="生产者子程序"></a>生产者子程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">produceri;:</span><br><span class="line">Var nextp:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">produce an item in nextp;</span><br><span class="line">Swait(empty,mutex);</span><br><span class="line">buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">Ssignal(mutex,full);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="消费者子程序"><a href="#消费者子程序" class="headerlink" title="消费者子程序"></a>消费者子程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Swait(full,mutex);</span><br><span class="line">nextc:=buffer[out];out:=(out+1)mod n</span><br><span class="line">Ssignal(mutex,empty);</span><br><span class="line">consume.the item in nextc;</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="同步问题程序设计要领"><a href="#同步问题程序设计要领" class="headerlink" title="同步问题程序设计要领"></a>同步问题程序设计要领</h4><ul><li>每个并发子程序关于互斥信号量的wait与signal操作必须在同一子程序中成对出现</li><li>关于资源信号量的wait与signal操作同样需成对出现，但可以分别处于不同的并发子程序中</li><li>每个并发子程序中的多个wait操作的顺序不能颠倒，即资源信号量wait操作执行在前而互斥信号量wait操作执行在后，否则可能引起死锁</li><li>每个并发子程序中的多个signal操作的执行顺序无关紧要</li><li>非临界资源访问操作无需放到临界区中，且最好放到临界区外</li></ul><h4 id="ZGS版"><a href="#ZGS版" class="headerlink" title="ZGS版"></a>ZGS版</h4><h5 id="主程序设计-1"><a href="#主程序设计-1" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var buffer:array [0..n-1]of item;</span><br><span class="line">in,out:integer :=0,0;</span><br><span class="line">mutexP,mutexC,empty,full semphore :=1,1,n,0；</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">producer;..produceri;...producery;</span><br><span class="line">consumer;...consumerj;...;consumerx;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="生产者子程序设计ZGS版"><a href="#生产者子程序设计ZGS版" class="headerlink" title="生产者子程序设计ZGS版"></a>生产者子程序设计ZGS版</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">produceri:</span><br><span class="line">Var nextp:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">produce an item in nextp;</span><br><span class="line">wait(empty);</span><br><span class="line">wait(mutexP);</span><br><span class="line">buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">signal(mutexP);</span><br><span class="line">signal(full);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="消费者子程序设计ZGS版"><a href="#消费者子程序设计ZGS版" class="headerlink" title="消费者子程序设计ZGS版"></a>消费者子程序设计ZGS版</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(full);</span><br><span class="line">wait(mutexC);</span><br><span class="line">nextc:=buffer[out];out :=(out+1) mod n;</span><br><span class="line">signal(mutexC);</span><br><span class="line">signal(empty);</span><br><span class="line">consume the item in nextc;</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>哲学家进餐问题是典型的同步问题</p><ul><li>五个哲学家共用一张圆桌，分别坐在环桌均匀摆放的五张椅子上，并全部实践着交替地进行思考和进餐的生活方式</li><li>圆桌上放有五支筷子，均匀排放在哲学家之间的位置上</li><li>哲学家饥饿时便试图去取用圆桌上最靠近他左右两端的两支筷子，且只有在同时拿到两支筷子时方可进餐，进餐完毕则把筷子放回原处，并继续进行思考</li></ul><h4 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h4><ol><li><p>筷子是临界资源<br>信号量数组chopstick[0..4],初始值均为1</p></li><li><p>第i个哲学家活动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Think;</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+1)mod 5])</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br></pre></td></tr></table></figure></li><li><p>上述解决方案在五个哲学家同时饥饿且各自拿起左边筷子的情况下会引起死锁</p></li><li><p>避免死锁的三种方法</p><ul><li>仅当哲学家左右两支筷子均可使用时，才允许他拿筷进餐</li><li>奇数号哲学家先拿左筷后拿右筷；而偶数号哲学家则相反</li><li>至多允许四个哲学家同时进餐，以保证至少有一个哲学家可以同时拿到两支筷子而进餐</li></ul></li></ol><h4 id="双筷齐举-AND型信号量"><a href="#双筷齐举-AND型信号量" class="headerlink" title="双筷齐举[AND型信号量]"></a>双筷齐举[AND型信号量]</h4><h5 id="主程序设计-2"><a href="#主程序设计-2" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">philosophy0;</span><br><span class="line">…;philosophyi;…</span><br><span class="line">philosophya;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="子程序设计"><a href="#子程序设计" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Think;</span><br><span class="line">Swait(chopstick[i],chopstick[(i+1)mod 5]);</span><br><span class="line">Eat;</span><br><span class="line">Ssignal(chopstick[i],chopstick[(i+1)mod 5]);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="双筷齐举-记录型信号量"><a href="#双筷齐举-记录型信号量" class="headerlink" title="双筷齐举[记录型信号量]"></a>双筷齐举[记录型信号量]</h4><h5 id="主程序设计-3"><a href="#主程序设计-3" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">mutex:semphore:=1;</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">philosophy0;</span><br><span class="line">…;philosophyi;…</span><br><span class="line">philosophya;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="子程序设计-1"><a href="#子程序设计-1" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Think;</span><br><span class="line">wait(mutex);</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+1)mod 5]);</span><br><span class="line">signal(mutex);</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="奇偶有别-记录型信号量"><a href="#奇偶有别-记录型信号量" class="headerlink" title="奇偶有别[记录型信号量]"></a>奇偶有别[记录型信号量]</h4><h5 id="主程序设计-4"><a href="#主程序设计-4" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">philosophy0;</span><br><span class="line">…;philosophyi;…</span><br><span class="line">philosophya;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="子程序设计-奇数"><a href="#子程序设计-奇数" class="headerlink" title="子程序设计[奇数]"></a>子程序设计[奇数]</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">philosophyi（i为奇数，即奇数号哲学家）：</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Think;</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+1)mod 5]);</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="子程序设计-偶数"><a href="#子程序设计-偶数" class="headerlink" title="子程序设计[偶数]"></a>子程序设计[偶数]</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">philosophyi（i为偶数，即偶数号哲学家）：</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Think;</span><br><span class="line">wait(chopstick[(i+1)mod 5]);</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="进餐限数-记录型信号量"><a href="#进餐限数-记录型信号量" class="headerlink" title="进餐限数[记录型信号量]"></a>进餐限数[记录型信号量]</h4><h5 id="主程序设计-5"><a href="#主程序设计-5" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1);</span><br><span class="line">limit:semphore:=4;</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">philosophy0;</span><br><span class="line">…;philosophyi;…</span><br><span class="line">philosophya;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="子程序设计-2"><a href="#子程序设计-2" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">Think;</span><br><span class="line">wait(limit);</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+1)mod 5]);</span><br><span class="line">signal(limit);</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li>读者一写者问题是指保证任何写者进程必须与其它进程互斥地访问共享数据对象（数据文件或记录)的同步问题。<ul><li>存在多个进程共享一个数据对象</li><li>只要求读的进程称为读者进程</li><li>拥有写或修改要求的进程称为写者进程</li><li>允许多个读者进程同时执行读操作</li><li>任何写者进程的执行具有排它性</li></ul></li><li>读者一写者问题常用于测试新同步原语</li></ol><h4 id="程序信号量及变量设计"><a href="#程序信号量及变量设计" class="headerlink" title="程序信号量及变量设计"></a>程序信号量及变量设计</h4><ol><li><p>写者进程与其它进程的互斥执行</p><p>写互斥信号量wmutex,初始值为1</p></li><li><p>读者进程之间的并发执行</p><p>读者进程计数变量readercount,表示正在执行的读者进程数量，其初始值为0</p></li><li><p>读者进程计数变量的互斥访问</p><p>readercounti对于多个读者进程而言是临界资源，应为之设置读互斥信号量rmutex,其初始值为1</p></li></ol><h4 id="主程序设计-6"><a href="#主程序设计-6" class="headerlink" title="主程序设计"></a>主程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var readercount:integer 0;</span><br><span class="line">rmutex,wmutex:semphore :=1,1;</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">reader;...;readeri ;...readerm;</span><br><span class="line">writer;..;writerj;..;writern;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="写者子程序设计"><a href="#写者子程序设计" class="headerlink" title="写者子程序设计"></a>写者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">writerj:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(wmutex);</span><br><span class="line">Perform write operation;</span><br><span class="line">signal(wmutex);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="读者子程序设计"><a href="#读者子程序设计" class="headerlink" title="读者子程序设计"></a>读者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readeri:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(rmutex);</span><br><span class="line">if readercount=0 then wait(wmutex);</span><br><span class="line">readercount:=readercount +1;</span><br><span class="line">signal(rmutex);</span><br><span class="line">Perform read operation;</span><br><span class="line">wait(rmutex);</span><br><span class="line">readercount:=readercount -1;</span><br><span class="line">if readercount=0 then signal(wmutex)</span><br><span class="line">signal(rmutex);</span><br><span class="line">until false:</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><ol><li>如果读者到来<ul><li>若为第一个读者：若无写者写，则开始读；否则插入wmutex队列等待</li><li>若非第一个读者：若前有读者在读（无论是否有写者已在等待)，新读者均开始读：否则插入rmutex队列[前面读者在等]等待</li></ul></li><li>如果写者到来<ul><li>无写者写且无读者读，则新写者开始写</li><li>有写者写或有读者读，则插入wmutex队列等待</li></ul></li></ol><h4 id="消除读者优先"><a href="#消除读者优先" class="headerlink" title="消除读者优先"></a>消除读者优先</h4><ol><li>一旦有写者到达，则后续的读者必须等待（无论当时是否有读者在读）</li><li>如果读者到来<ul><li>有写者写或有写者等，则新读者等待</li><li>无写者写且无写者等，则新读者可读</li></ul></li><li>如果写者到来<ul><li>无读者读且无写者写，则新写者可写</li><li>有读者读或有写者写，则新写者等待</li></ul></li></ol><h4 id="公平型读者-写者"><a href="#公平型读者-写者" class="headerlink" title="公平型读者-写者"></a>公平型读者-写者</h4><h5 id="主程序设计-7"><a href="#主程序设计-7" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var readercount:integer 0;</span><br><span class="line">S,rmutex,wmutex:semphore :=1,1,1;</span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">reader;...;readeri ;...readerm;</span><br><span class="line">writer;..;writerj;..;writern;</span><br><span class="line">parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="读者子程序设计-1"><a href="#读者子程序设计-1" class="headerlink" title="读者子程序设计"></a>读者子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">readeri:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(S);</span><br><span class="line">wait(rmutex);</span><br><span class="line">if readercount=0 then wait(wmutex);</span><br><span class="line">readercount:=readercount +1;</span><br><span class="line">signal(rmutex);</span><br><span class="line">signal(S);</span><br><span class="line">Perform read operation;</span><br><span class="line">wait(rmutex);</span><br><span class="line">readercount:=readercount -1;</span><br><span class="line">if readercount=0 then signal(wmutex)</span><br><span class="line">signal(rmutex);</span><br><span class="line">until false:</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="写者子程序设计-1"><a href="#写者子程序设计-1" class="headerlink" title="写者子程序设计"></a>写者子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">writerj:</span><br><span class="line">begin</span><br><span class="line">repeat</span><br><span class="line">wait(S)；</span><br><span class="line">wait(wmutex);</span><br><span class="line">Signal(S);</span><br><span class="line">Perform write operation;</span><br><span class="line">signal(wmutex);</span><br><span class="line">until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p><strong>程序的执行首先要加载装入到内存，然后程序的运行从内存提取加载到CPU执行，重点如何把程序里的地址转化成内存的物理单元的物理地址</strong></p><h3 id="用户程序处理过程"><a href="#用户程序处理过程" class="headerlink" title="用户程序处理过程"></a>用户程序处理过程</h3><p>源程序（符号名空间）</p><p><strong>编译程序</strong></p><p>目标模块（目标&#x2F;相对地址空间）</p><p><strong>链接程序</strong></p><p>装入模块（统一的目标地址空间）</p><p><strong>装入程序</strong></p><p>内存（物理地址空间）</p><h3 id="程序处理与内存管理"><a href="#程序处理与内存管理" class="headerlink" title="程序处理与内存管理"></a>程序处理与内存管理</h3><h4 id="程序地址空间及形成"><a href="#程序地址空间及形成" class="headerlink" title="程序地址空间及形成"></a>程序地址空间及形成</h4><ul><li>目标模块（由编译&#x2F;汇编得到）：相对地址</li><li>链接过程实现各目标模块相对地址的统一</li></ul><h4 id="内存管理逻辑部件"><a href="#内存管理逻辑部件" class="headerlink" title="内存管理逻辑部件"></a>内存管理逻辑部件</h4><ul><li>MMU负责将逻辑地址转换为物理地址</li><li>X86体系结构MMU支持分页和分段机制</li></ul><h4 id="内存管理模式"><a href="#内存管理模式" class="headerlink" title="内存管理模式"></a>内存管理模式</h4><p>实模式和保护模式</p><h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><h4 id="INTERFACE（接口、界面、介面）"><a href="#INTERFACE（接口、界面、介面）" class="headerlink" title="INTERFACE（接口、界面、介面）"></a>INTERFACE（接口、界面、介面）</h4><p>接口是连接两个物体的边界，通过这个界面，两边可以很好地对话</p><ul><li>硬件-硬件：USB、VGA、HDML、</li><li>软件-硬件：指令集</li><li>软件-软件：Application Programming Interface（API）</li></ul><h4 id="VIRTUAL-MACHINE"><a href="#VIRTUAL-MACHINE" class="headerlink" title="VIRTUAL MACHINE"></a>VIRTUAL MACHINE</h4><p>操作系统向用户提供一个容易理解和使用的“计算机”（虚拟的)，用户对这个“计算机”的操作都将被操作系统转成对计算机硬件的操作</p><h4 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h4><h5 id="用户角度"><a href="#用户角度" class="headerlink" title="用户角度"></a>用户角度</h5><ul><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不<br>容易出错</li></ul><h5 id="系统角度"><a href="#系统角度" class="headerlink" title="系统角度"></a>系统角度</h5><ul><li>管理资源<ul><li>硬件资源（处理机，存储器，设备)</li><li>信息资源（文件）</li></ul></li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和对计算机不正当的使用</li></ul><h4 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h4><ol><li>操作系统在用户和计算机硬件之间扮演了中间人的角色</li><li>操作系统的目标是为提供一个方便高效执行代码的环境</li><li>操作系统是管理计算机硬件的软件</li></ol><h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4><ul><li>memory</li><li>CPU</li><li>disk controller-&gt;disks</li><li>mouse、keyboard、printer、monitor-&gt;USB controller</li><li>monitor-&gt;graphics adapter(显示适配器)-&gt;显卡</li><li>Bus</li></ul><h5 id="主引导扇区（BOOT-SECTOR）"><a href="#主引导扇区（BOOT-SECTOR）" class="headerlink" title="主引导扇区（BOOT SECTOR）"></a>主引导扇区（BOOT SECTOR）</h5><ol><li>硬盘的0柱面、0磁头、1扇区称为主引导扇区，在这扇区里存放着一段代码：主引导记录MBR(Main Boot Record),它用于硬盘启动时将系统控制权转给用户指定的、在分区表中登记了某个操作系统分区</li><li>MBR的内容是在硬盘分区时由分区软件写入该扇区的，MBR不属于任何一个操作系统，不随操作系统的不同而不同，即使不同，MBR也不会夹带操作系统的性质，具有公共引导的特性</li></ol><h5 id="BOOTSTRAP-gt-OS自己把自己拉启动"><a href="#BOOTSTRAP-gt-OS自己把自己拉启动" class="headerlink" title="BOOTSTRAP-&gt;OS自己把自己拉启动"></a>BOOTSTRAP-&gt;OS自己把自己拉启动</h5><p>Pull oneself up by one’s bootstraps.</p><h5 id="BOOTSTRAP-OF-COMPUTER"><a href="#BOOTSTRAP-OF-COMPUTER" class="headerlink" title="BOOTSTRAP OF COMPUTER"></a>BOOTSTRAP OF COMPUTER</h5><ul><li>打开电源</li><li>CPU将控制权交给BIOS（基本输入输出系统，存放在CMOS中)</li><li>BIOS运行一个程序：通电自测试程序</li><li>BIOS确认所有外部设备：硬盘或扩充卡</li><li>BIOS找到磁盘的引导区，将其中的主引导程序bootloader装入内存。（主引导程序是一段代码，它可以将OS余下部分装入内存)</li><li>引导操作系统结束，操作系统接管计算机</li><li>操作系统等待事件发生…</li></ul><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul><li>当有事件（Event)发生时，CPU会收到一个中断(Interrupt)信号，可以是硬中断也可以是软件中断。</li><li>CPU会停下正在做的事，转而执行中断处理程序执行完毕会回到之前被中断的地方继续执行。</li><li>操作系统是一个以中断驱动的系统</li></ul><h5 id="STORAGE-SYSTEM-存储系统"><a href="#STORAGE-SYSTEM-存储系统" class="headerlink" title="STORAGE SYSTEM(存储系统)"></a>STORAGE SYSTEM(存储系统)</h5><ol><li>CPU负责将指令(Instruction)从内存（Memory)读入，所以程序必须在内存中才能运行。</li><li>内存以字节为存储单位，每个字节都有一个地址与之对应。通过load&#x2F;store:指令即可访问指定地址的内存数据<ul><li>load:将内存数据装入寄存器(Register)</li><li>store:将寄存器数据写入内存</li></ul></li></ol><h5 id="I-x2F-O结构"><a href="#I-x2F-O结构" class="headerlink" title="I&#x2F;O结构"></a>I&#x2F;O结构</h5><ul><li>存储器只是众多IO设备中的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且他有着很强的扩展性。</li><li>管理IO设备是操作系统非常重要的组成部分，操作系统中有一个专门的O子系统负责完成这项工作。</li></ul><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><h5 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h5><ul><li>Single-processor System</li><li>只有一颗主CPU,执行通用指令集。</li><li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等。<ul><li>它们能够执行的指令有限，不处理用户进程</li><li>操作系统会向它们发出任务，并监控它们的状态</li></ul></li></ul><h5 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h5><ul><li>Multiprocessor&#x2F;Multicore System</li><li>有两个或多个紧密通信的CPU,它们共享计算机总线、时钟、内存和外设等。<ul><li>非对称处理(Asymmetric multiprocessing)<br>对称处理(Symmetric MuliProcessing)</li></ul></li></ul><h5 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h5><ul><li>Clustered System</li><li>该系统由若干节点（node)通过网络连接在一起每个节点可为单处理器系统或多处理器系统，节点之间是松耦合(loosely coupled)关系。<ul><li>高可用性(high availability)</li><li>高性能计算(high-performance computing)</li></ul></li></ul><h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><h5 id="单用户单模式"><a href="#单用户单模式" class="headerlink" title="单用户单模式"></a>单用户单模式</h5><p>输入500个字符（花78ms),经CPU处理52ms后，将结果2000个字符存到磁带上（花20ms),重复进行。CPU利用率&#x3D;52&#x2F;(78+52+20)≈35%</p><h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h5><ul><li>操作系统最重要的一点是具有多道程序(multiprogramming)能力。</li><li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用得CPU总有一个执行任务，从而提高CPU利用率。</li><li>实现的硬件保证：处理器和IO设备具备并行工作的能力</li></ul><h5 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h5><ul><li>分时系统（time sharing)也称多任务系统(multi-tasking)，是多道程序设计的自然延伸。</li><li>允许多个用户共享一台计算机<ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令到得到即时结果的时间称为响应时间</li></ul></li><li>第一个分时系统CTSS由MIT于1962年开发出来</li></ul><h5 id="引发的其他模式"><a href="#引发的其他模式" class="headerlink" title="引发的其他模式"></a>引发的其他模式</h5><ul><li>处理器调度（CPU Scheduling)</li><li>交换(Swapping）</li><li>虚拟内存(Virtual Memory)</li><li>磁盘管理（Disk Management）</li><li>同步(Synchronization)</li><li>死锁(Deadlock)</li></ul><h3 id="操作系统提供的服务"><a href="#操作系统提供的服务" class="headerlink" title="操作系统提供的服务"></a>操作系统提供的服务</h3><h4 id="USER-INTERFACE"><a href="#USER-INTERFACE" class="headerlink" title="USER INTERFACE"></a>USER INTERFACE</h4><p>Almost all operating system have a user interface(UI).It offers a way for users to interface（交互） with OS.</p><h5 id="CLI（Command-Line-Interface）（命令行）"><a href="#CLI（Command-Line-Interface）（命令行）" class="headerlink" title="CLI（Command Line Interface）（命令行）"></a>CLI（Command Line Interface）（命令行）</h5><p>command interpreter(shell)命令解释器</p><h5 id="GUI-Graphic-User-Interface"><a href="#GUI-Graphic-User-Interface" class="headerlink" title="GUI(Graphic User Interface)"></a>GUI(Graphic User Interface)</h5><p>A user friendly graphical user interface.</p><h5 id="Batch-批处理"><a href="#Batch-批处理" class="headerlink" title="Batch(批处理)"></a>Batch(批处理)</h5><ul><li>It is a file which contains commands and directives.</li><li>Demonstration …</li></ul><h4 id="系统调用（SYSTEM-CALLS）"><a href="#系统调用（SYSTEM-CALLS）" class="headerlink" title="系统调用（SYSTEM CALLS）"></a>系统调用（SYSTEM CALLS）</h4><ol><li>系统调用提供了访问和使用操作系统所提供的服务的接口<ul><li>系统调用的实现代码是操作系统级的</li><li>这个接口通常是面向程序员的</li></ul></li><li>API(Application Programming Interface)):指明了参数和返回值的一组函数。<ul><li>应用程序App的开发人员通过透过API间接访问了系统调用</li><li>Windows API POSIX API JAVA API</li></ul></li></ol><h5 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h5><ul><li>每个系统调用都有一个唯一的数字编号，被称为系统调用</li><li>用户代码调用API时，API中会向系统调用接口指明其所要用的系统调用号，操作系统内核中维护了一张索引表，依据这个调用号可以检索到访系统调用代码在内核中的位置。</li></ul><h4 id="双重模式（DUAL-MODE）"><a href="#双重模式（DUAL-MODE）" class="headerlink" title="双重模式（DUAL MODE）"></a>双重模式（DUAL MODE）</h4><ol><li>现代计算机系统有一个特殊的硬件，用于划分系统的运行状态，至少需要两种单独运行模式：<ul><li>用户模式(user mode)：执行用户代码</li><li>内核模式(kernel mode):执行操作系统代码</li></ul></li><li>目的：确保操作系统正确的运行</li><li>实现方式：用一个硬件模式位来表示当前模式：0表示内核模式，1<br>表示用户模式。</li></ol><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><h4 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h4><ul><li>A program is a passive entity,such as a file containing a list of instructions stored on disk(often called an executable file).</li><li>A program becomes a process when an executable file is loaded into memory.</li><li>A process is an active entity,with a program counter specifying the next instruction to execute an a set of associated resources</li></ul><h4 id="PROGRAM-COUNTER"><a href="#PROGRAM-COUNTER" class="headerlink" title="PROGRAM COUNTER"></a>PROGRAM COUNTER</h4><ul><li>程序计数器(PC)是一个CPU中的寄存器，里面存放下一条要执行指令的内存地址<br>在Intel x86和Itanium微处理器中，它叫做指令指针（Instruction Pointer,IP），有时又称为指令地址寄存器(instruction address register,IAR)、指令计数器</li><li>通常，CPU在取完一条指令之后会将PC寄存器的值加“1”，以计算下条要执行指令的地址。</li></ul><h4 id="PROCESS-IN-MEMORY"><a href="#PROCESS-IN-MEMORY" class="headerlink" title="PROCESS IN MEMORY"></a>PROCESS IN MEMORY</h4><ul><li>text：代码</li><li>data：全局和静态变量</li><li>stack：栈用于存放局部变量、函数返回地址</li><li>heap：堆用于程序运行时的动态内存分配</li></ul><h4 id="并发的进程"><a href="#并发的进程" class="headerlink" title="并发的进程"></a>并发的进程</h4><ul><li>Concurrency:the fact of two or more events or circumstances happening（存在） or existing at the same time.</li><li>并行：running at the same time</li><li>并发进程可能无法一次性执行完毕，会<strong>走走停停</strong>。</li><li>一个进程在执行过程中可能会被另一个进程替换占有CPU,这个过程称作“<strong>进程切换</strong>”</li></ul><h4 id="进程的定义-1"><a href="#进程的定义-1" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol><li>进程是一个程序的一次执行过程<ul><li>能够具体完成的</li><li>是在某个数据集合上完成的</li><li>执行过程是可并发的</li></ul></li><li>进程是资源分配、保护和调度的基本单位</li></ol><h4 id="进程状态（PROCESS-STATE）"><a href="#进程状态（PROCESS-STATE）" class="headerlink" title="进程状态（PROCESS STATE）"></a>进程状态（PROCESS STATE）</h4><p>进程在执行期间自身的状态会发生变化，进程有三种基本状态，分别是：</p><ol><li>运行态(Running)：此时进程的代码在CPU上运行</li><li>就绪态(Ready):进程具备运行条件，等待分配CPU</li><li>等待态(Waiting)：进程在等待某些事件的发生（比如IO操作结束或是一个信号)</li></ol><h4 id="进程何时离开CPU"><a href="#进程何时离开CPU" class="headerlink" title="进程何时离开CPU"></a>进程何时离开CPU</h4><ol><li>内部事件<ul><li>进程<strong>主动放弃</strong>（yield）CPU，进入等待&#x2F;终止状态</li><li>例如使用I&#x2F;O设备，（非）正常结束如除以0</li></ul></li><li>外部事件<ul><li>进程被剥夺CPU使用权，进入就绪状态。这个动作叫<strong>抢占</strong>(preempt)。</li><li>例如时间片到达，高优先权进程到达。</li></ul></li></ol><h3 id="进程切换和进程调度"><a href="#进程切换和进程调度" class="headerlink" title="进程切换和进程调度"></a>进程切换和进程调度</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>并发进程中，一个进程在执行过程中可能会被另一个进程替换占有CPU,这个过程称作“<strong>进程切换</strong>”。</p><h4 id="中断技术（Interrupt）"><a href="#中断技术（Interrupt）" class="headerlink" title="中断技术（Interrupt）"></a>中断技术（Interrupt）</h4><p>中断是指程序执行过程中</p><ul><li>当发生某个事件时，中止CPU上现行程序的运行</li><li>引出该事件的处理程序执行</li><li>执行完毕返回源程序中断点继续执行</li></ul><h4 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h4><h5 id="外中断（interrupt）"><a href="#外中断（interrupt）" class="headerlink" title="外中断（interrupt）"></a>外中断（interrupt）</h5><p>来自处理器之外的硬件中断信号</p><ul><li>如时钟中断、键盘中断、外围设备中断</li><li>外部中断均是异步中断</li></ul><h5 id="内中断（异常Exception）"><a href="#内中断（异常Exception）" class="headerlink" title="内中断（异常Exception）"></a>内中断（异常Exception）</h5><p>来自于处理器内部，指令执行过程中发生的中断，属同步中断</p><ul><li>硬件异常：掉电、奇偶校验错误等</li><li>程序异常：非法操作、地址越界、断点、除数为0</li><li>系统调用</li></ul><h4 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h4><h5 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h5><p>只能在内核态运行的指令</p><ul><li>I&#x2F;O指令和停止整个系统指令</li><li>关闭所有中断</li><li>设置定时器</li><li>进程切换</li></ul><h5 id="非特权指令"><a href="#非特权指令" class="headerlink" title="非特权指令"></a>非特权指令</h5><p>只能运行在用户态</p><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><ul><li>中断是用户态向核心态转换的唯一途径！系统调用实质上也是一种中断</li><li>OS提供LoadPSW指令装载用户进程返回用户状态</li></ul><h4 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h4><h5 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h5><ul><li>进程需要进入等待状态</li><li>进程被抢占CPU而进入就绪状态</li></ul><h5 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h5><ul><li>CPU从用户态切换到核心态</li><li>保存被中断进程的上下文信息（Context）</li><li>修改被中断进程的控制信息（如状态等）</li><li>将被中断的进程加入相应的状态队列</li><li>调度一个新的进程并恢复它的上下文信息</li></ul><p><strong>进程的上下文包含了进程在内存中的text、data、heap、stack和PCB</strong></p><p>运行实体：text、data、heap、stack</p><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>PCB包含了一个指定进程的许多信息，包括如下</p><ul><li>进程状态</li><li>进程编号PID</li><li>PC值</li><li>寄存器的值</li><li>内存信息</li><li>打开的文件</li></ul><h4 id="进程调度（PROCESS-SCHEDULING）"><a href="#进程调度（PROCESS-SCHEDULING）" class="headerlink" title="进程调度（PROCESS SCHEDULING）"></a>进程调度（PROCESS SCHEDULING）</h4><p>进程在整个生命周期中会在各个调度队列中迁移，由操作系统的一个调度器（scheduler）来执行。</p><h4 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h4><p>用于创建一个新进程，该进程为当前进程的子进程，创建的方法：fork（）；</p><p>父进程在执行了fork后，将当前进程在内存中的所有数据原模原样复制一份，从fork（）开始并发执行fork（）之后的所有代码</p><p>fork（）的返回值：</p><ul><li>如果成功创建子进程，对于父子进程fork会返回不同的值，</li><li>对于父进程它的返回值是子进程的进程id值</li><li>对于子进程它的返回值是0</li><li>如果创建失败，返回值为-1</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/09/23/2023-9-23-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/09/23/2023-9-23-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><p>网络 计算机用网络设备连起来</p><p>互联网 许多网络通过路由器连起来</p><p>因特网 全球最大的一个互联网</p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p>边缘部分（计算机、平板、手机）</p><ul><li>客户服务器方式</li><li>对等方式p2p：客户端也可以作为服务器</li></ul><p>核心部分（路由器）</p><ul><li>电路交换：适用于数据量很大的实时性传输、核心路由器之间、应用如固定电话</li><li>报文交换</li><li>分组交换</li></ul><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p>广域网（WAN）</p><p>城域网（MAN）</p><p>局域网（LAN）</p><p>个人区域网（PAN）</p><h4 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h4><p>公用网</p><p>专用网</p><h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p>总线型</p><p>环型</p><p>星型</p><p>树型</p><p>网状</p><h4 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h4><p>电路交换</p><p>报文交换</p><p>分组交换</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>资源子网</p><p>通信子网</p><p>接入网</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h4><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称data rate或bit rate 单位是b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s</p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>数字信道上所传送的最高数据率，即最大速率，单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s</p><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h4><p>在单位时间内通过某个网络的数据量，即通过所有链路的网络流量，单位b&#x2F;s，Mb&#x2F;s等</p><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><p>①发送时延：计算机发出数据的时间</p><p>发送时延&#x3D;数据块长度（比特）&#x2F;信道带宽（比特&#x2F;秒）</p><p>②传播时延：媒体上传输时消耗的时间</p><p>传播时延&#x3D;信道长度（米）&#x2F;信号在信道上的传播速率（米&#x2F;秒）</p><p>③处理时延：网络结点存储转发处理时间</p><p>④排队时延：网络结点缓存队列排队时间</p><h4 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h4><p>数据链路上能够承载的数据量</p><p>时延带宽积&#x3D;传播时延×带宽</p><h4 id="6-往返时间RTT"><a href="#6-往返时间RTT" class="headerlink" title="6.往返时间RTT"></a>6.往返时间RTT</h4><p>从发送方发送数据开始，到发送方收到接收方确认</p><h4 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h4><p>①信道利用率：有数据通过时间&#x2F;（有+无）数据通过时间</p><p>②网络利用率：信道利用率加权平均值</p><p>D&#x3D;D0&#x2F;1-U</p><p>D0表示网络空闲时的时延</p><p>D表示网络当前的时延</p><p>U表示信道利用率</p><h3 id="OSI参考模型（7层）"><a href="#OSI参考模型（7层）" class="headerlink" title="OSI参考模型（7层）"></a>OSI参考模型（7层）</h3><p>应用层 能够产生网络流量能够和用户交互的应用程序</p><p>表示层 加密、压缩、开发人员考虑的问题</p><p>会话层 服务和客户端建立的会话 查木马 netstat -nb</p><p>传输层 可靠传输建立会话 不可靠传输 流量控制</p><p>网络层 IP地址编址 选择最佳路径</p><p>数据链路层 数据如何封装 添加物理层地址 MAC</p><p>物理层 电压 接口标准</p><h3 id="网络排错"><a href="#网络排错" class="headerlink" title="网络排错"></a>网络排错</h3><p>底层往高层，逐一排查</p><h3 id="网络安全和OSI参考模型"><a href="#网络安全和OSI参考模型" class="headerlink" title="网络安全和OSI参考模型"></a>网络安全和OSI参考模型</h3><p>物理层安全</p><p>数据链路层安全 ADSL AP密码</p><p>网络层安全</p><p>应用层安全 SQL注入漏洞 长传漏洞</p><h3 id="开放系统信息交换涉及的几个概念"><a href="#开放系统信息交换涉及的几个概念" class="headerlink" title="开放系统信息交换涉及的几个概念"></a>开放系统信息交换涉及的几个概念</h3><p>实体（entity）：交换信息硬件和软件的进程</p><p>协议（protool）：控制两个对等实体通信的规则</p><p>服务（service）：下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能</p><p>服务访问点（SAP）：相邻两层实体间交换信息的地方</p><h3 id="五层协议对应的数据单元"><a href="#五层协议对应的数据单元" class="headerlink" title="五层协议对应的数据单元"></a>五层协议对应的数据单元</h3><p>应用层：传输数据单元PDU</p><p>运输层：运输层报文</p><p>网络层：IP数据报（IP分组）</p><p>数据链路层：数据帧</p><p>物理层：比特</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>解决如何在连接各种计算机的传输媒体上传输数据比特流，主要任务时确定与传输媒体的接口的一些特性，如下</p><ul><li>机械特性：接口形状、大小、引线数目</li><li>电气特性：规定电压范围</li><li>功能特性：如规定-5V表示0，+5V表示1</li><li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul><h3 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h3><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p>通信的目的是传送消息</p><ul><li><p>数据：运输消息的实体</p></li><li><p>信号：数据的电气或电磁的表现</p><p>模拟信号：消息的参数取值是连续的</p><p>数字信号：消息的参数取值是离散的</p></li><li><p>码元：在使用域的波形表示数字信号时，则表示不同离散数值的基本波形就成为码元</p></li></ul><h4 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h4><p>信道一般表示向一个方向传输信息的媒体，通信线路往往包含一条发送信息的信道和一条接收信息的信道</p><ul><li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。例如广播电台</li><li>双向交替通信（半双工通信）：通信双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。例如对讲机</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息。例如打电话</li></ul><h4 id="基带信号和带通信号"><a href="#基带信号和带通信号" class="headerlink" title="基带信号和带通信号"></a>基带信号和带通信号</h4><ul><li>基带信号（基本频带信号)：来自信源的信号。如计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，如我们说话的声波</li><li>带通信号：把基带信号经过载波调制后，把信号的频率范围搬到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）</li></ul><h4 id="几种最基本的调制方法"><a href="#几种最基本的调制方法" class="headerlink" title="几种最基本的调制方法"></a>几种最基本的调制方法</h4><ul><li>调幅（AM）：载波的振幅随基带数字信号而变化</li><li>调频（FM）：载波的频率随基带数字信号而变化</li><li>调相（PM）：载波的初始相位随基带数字信号而变化</li></ul><h4 id="常用的编码"><a href="#常用的编码" class="headerlink" title="常用的编码"></a>常用的编码</h4><ul><li><p>单极性不归零码：只使用一个电压值，用高电平表示1，没电压表示0</p></li><li><p>双极性不归零码：用正电平和负电平分别表示二进制数据的1和0，正负幅值相等</p></li><li><p>双极性归零码：正负零三个电平，信号本身携带同步信息</p></li><li><p>曼切斯特编码：bit中间有信号低-高跳变为0，bit中间有信号高-低跳变为1</p></li><li><p>差分曼切斯特编码：bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0， bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1</p></li></ul><h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><ul><li>有失真，但可识别</li><li>失真大，无法识别</li></ul><h4 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h4><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决成为不可能</p><p><strong>理想低通信道的最高码元传输速率&#x3D;2WBaud</strong></p><ul><li>W是理想低通信道的带宽，单位为Hz</li><li>Baud是波特，是码元传输速率的单位</li></ul><h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率</p><p><strong>信道的极限信息传输速率C可表达为C&#x3D;Wlog2（1+S&#x2F;N）b&#x2F;s</strong></p><ul><li>W为信道带宽（Hz为单位）</li><li>S为信道内所传信号的平均功率</li><li>N为信道内部的高斯噪声功率</li></ul><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><h4 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h4><p>导向传输媒体中，电磁波沿着固体媒体传播</p><p>1.双绞线</p><ul><li>屏蔽双绞线STP</li><li>无屏蔽双绞线UTP</li></ul><p>2.同轴电缆</p><ul><li>50Ω同轴电缆用于数字传输，由于多用于基带传输，也叫基带同轴电缆</li><li>75Ω同轴电缆由于模拟传输，即宽带同轴电缆</li></ul><p>3.光缆</p><h4 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h4><p>自由空间，其中的电磁波传输被成为无线传输。无线传输所使用的频段很广</p><p>短波通信主要靠电离层的反射，但短波通信的通信质量较差</p><p>微波在空间主要是直线传播</p><ul><li>地面微波接力通信</li><li>卫星通信</li></ul><h4 id="物理层设备-集线器（hub）"><a href="#物理层设备-集线器（hub）" class="headerlink" title="物理层设备-集线器（hub）"></a>物理层设备-集线器（hub）</h4><p>工作特点：只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力</p><p>最大传输距离：100m</p><p>集线器是一个大的冲突域</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>复用是通信技术中的基本概念</p><p>1.频分复用FDM</p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p><p>频分复用的所有用户在同样的时间占用不同的带宽资源（“带宽”是频率带宽而不是数据的发送速率）</p><p>2.时分复用技术TDM：</p><p>将时间划分成一段段等长的时分复用帧（TDM帧），每个时分复用的用户在每一个TDM帧中所占用固定序号的时隙。</p><p>每一个用户所占用的时隙是周期性的出现（其周期就是TDM帧的长度对应的时间）</p><p>TDM信号也称等时信号。</p><p>时分复用的所有用户是在不同的时间占用同样的频带宽度</p><p>3.码分复用技术CDM</p><p>常用的名词是码分多址CDMA，例如手机通话就会使用到码分复用技术</p><p>每个比特时间划分为m个短的间隔，称为码片</p><h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路电话</p><h3 id="带宽接入技术"><a href="#带宽接入技术" class="headerlink" title="带宽接入技术"></a>带宽接入技术</h3><h4 id="xDSL技术"><a href="#xDSL技术" class="headerlink" title="xDSL技术"></a>xDSL技术</h4><p>把0-4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用</p><h4 id="光纤同轴混合网HFC网"><a href="#光纤同轴混合网HFC网" class="headerlink" title="光纤同轴混合网HFC网"></a>光纤同轴混合网HFC网</h4><p>在有线电视网CATV的基础上开发的一种居民宽带接入网</p><h4 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h4><ul><li>光纤到家FTTH</li><li>光纤到大楼FTTB</li><li>光纤到路边FTTC</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层的信道类型"><a href="#数据链路层的信道类型" class="headerlink" title="数据链路层的信道类型"></a>数据链路层的信道类型</h3><ol><li>点对点信道。使用一对一的点对点通信方式</li><li>广播信道。一对多的广播通信方式，因此过程比较复杂。</li></ol><h3 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h3><ul><li><p>链路（link）是一条点到点的物理线路段，中间没有任何其他点。</p><p>一条链路只是一条通路的一个组成部分。例如网线、电话线</p></li><li><p>数据链路（data link）除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p>最常用的方法就是使用适配器（即网卡）来实现这些协议的硬件和软件</p><p>一般适配器都包括了数据链路层和物理层这两层的功能</p></li></ul><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧</p><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul><li>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限</li><li>首部和尾部的一个重要作用就是进行帧定界</li></ul><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>若传输的数据不是仅由“可打印字符”组成时，就会出问题</p><p><strong>用字符填充法解决透明传输的问题</strong></p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。字节填充或者字符填充—-接收端的数据链路层在将数据送往网络层之前删除插入的转义字符</p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>传输过程中可能会产生<strong>比特差错</strong>：1可能会变成0而0也可能变成1</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率为<strong>误码率</strong>BER</p><h5 id="循环冗余检验CRC"><a href="#循环冗余检验CRC" class="headerlink" title="循环冗余检验CRC"></a><strong>循环冗余检验CRC</strong></h5><p>在发送端，先把数据划分成组。在待传送的数据M（M的位数为k）后面再添加供差错检测用的n为冗余码一起发送</p><p>冗余码的计算</p><ul><li>用二进制的模2运算进行2^n乘M的运算，这相当于在M后面添加n个0</li><li>得到的（k+n）位的数除以事先选定好的长度为（n+1）位的除数P，得出商是Q而余数是R（FCS），余数R比除数P少一位，即R是n位。</li></ul><p>仅用循环冗余检验CRC差错检测技术只能做到<strong>无差错接受</strong>，要做到可靠传输就必须加上确认和重传机制。考虑：帧重复、帧丢失、帧乱序的情况。</p><p>可以说CRC是一种<strong>无比特差错</strong>，而不是<strong>无传输差错</strong>的检测机制</p><h5 id="帧检验序列FCS"><a href="#帧检验序列FCS" class="headerlink" title="帧检验序列FCS"></a><strong>帧检验序列FCS</strong></h5><p>在数据后面加上的冗余码称为帧检验序列FCS，循环冗余校验CRC和帧检验序列FCS并不等同</p><ul><li>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码</li><li>FCS可以由CRC这种方法得出，但CRC并非原来获得FCS的唯一办法</li></ul><h3 id="PPP协议使用场合"><a href="#PPP协议使用场合" class="headerlink" title="PPP协议使用场合"></a>PPP协议使用场合</h3><p>PPP协议拨号有身份验证、记账的功能。全世界使用最多的数据链路层协议是点对点协议PPP，用户使用拨号电话接入因特网时，一般都是使用PPP协议。</p><h4 id="PPP协议三个组成部分"><a href="#PPP协议三个组成部分" class="headerlink" title="PPP协议三个组成部分"></a>PPP协议三个组成部分</h4><ul><li>数据链路层协议（HDLC）可以用于异步串行或者同步串行介质</li><li>使用LCP（链路控制协议）建立并维护数据链路连接，身份验证</li><li>网络控制协议（NCP）允许在点到点连接上使用多种网络层协议</li></ul><h4 id="PPP填充方法"><a href="#PPP填充方法" class="headerlink" title="PPP填充方法"></a>PPP填充方法</h4><ul><li>字节填充</li><li>零比特填充：在5个连1之后填入0</li></ul><h3 id="以太网的特点"><a href="#以太网的特点" class="headerlink" title="以太网的特点"></a>以太网的特点</h3><h4 id="局域网的特点与优点"><a href="#局域网的特点与优点" class="headerlink" title="局域网的特点与优点"></a>局域网的特点与优点</h4><p>局域网最主要的特点：网络为一个单位所拥有，且地理范围和站点数目均有限</p><p>主要优点</p><ul><li>广播功能，从一个站点可很方便的访问全网，局域网上的主机可以共享连接在局域网上的各种硬件和软件资源</li><li>便于系统的扩展和演变，设备的位置可灵活调整和改变</li><li>提高系统的可靠性、可用性和生存性</li></ul><h4 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h4><p>1.静态划分信道</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul><p>2.动态媒体接入控制（多点接入）</p><ul><li>随机接入（主要被以太网采用）</li><li>受控接入，如多点线路探询或者轮询（目前已不被采用）</li></ul><h4 id="广播信道的数据链路层）载波监听多点接入-x2F-碰撞检测-以太网使用CSMA-x2F-CD协议"><a href="#广播信道的数据链路层）载波监听多点接入-x2F-碰撞检测-以太网使用CSMA-x2F-CD协议" class="headerlink" title="(广播信道的数据链路层）载波监听多点接入&#x2F;碰撞检测 以太网使用CSMA&#x2F;CD协议"></a>(广播信道的数据链路层）载波监听多点接入&#x2F;碰撞检测 以太网使用CSMA&#x2F;CD协议</h4><ul><li><strong>多点接入</strong>表示许多计算机以多点接入的方式连接在一根总线上</li><li><strong>载波监听</strong>是指每一个站在发送数据之前先要用电子技术检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发送碰撞</li></ul><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>计算机边发送数据边检测信道上的信号电压大小</p><ul><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li>所谓碰撞就是发生了冲突，因此碰撞检测也成为冲突检测</li></ul><h4 id="检测到碰撞后"><a href="#检测到碰撞后" class="headerlink" title="检测到碰撞后"></a>检测到碰撞后</h4><ul><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来</li><li>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立马停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送</li></ul><h4 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h4><p>使用CSMA&#x2F;CD协议的以太网不能进行全双工通信而只能进行双向交替通信</p><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p>最先发送数据帧的站，在发送数据帧后至多经过时间2τ就可知道发送的数据帧是否遭到了碰撞</p><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发送碰撞。</p><ul><li>以太网的端到端往返时延2τ成为争用期，或碰撞窗口。通常，取51.2μs为争取期的长度</li><li>对于10Mb&#x2F;s以太网，在争用期内可发送512bit，即64字节</li><li>以太网发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突</li></ul><h4 id="最短有效帧长"><a href="#最短有效帧长" class="headerlink" title="最短有效帧长"></a>最短有效帧长</h4><ul><li>如果发生冲突，就一定是在发送的前64字节之内</li><li>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于64字节</li><li>以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧</li></ul><h4 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h4><p>发生碰撞的站在停止发送数据之后，要推迟一个随机时间再发送数据</p><ul><li>确定基本退避时间，一般是争用期2τ</li><li>定义参数k，k&#x3D;Min[重传次数，10]</li><li>从整数集合[0，1，…，（2^k-1)]中随机取出一个数，记为r。重传所需时延就是r倍的基本退避时间</li><li>当重传16次仍不能成功时即丢弃该帧，并向高层报告</li></ul><h4 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h4><ol><li>DIX Ethernet V2标准世界上第一个局域网产品的规约</li><li>IEEE的802.3标准</li></ol><h4 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h4><p>802委员会将局域网的数据链路层拆分成两个子层</p><ul><li>逻辑链路控制LLC子层</li><li>媒体接入控制MAC子层</li></ul><h4 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h4><ul><li>不可靠的交付，即尽最大努力的交付</li><li>当接收站收到有差错的数据帧就丢弃此帧，其他什么也不做。差错的纠正由高层来决定</li><li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送</li></ul><h4 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h4><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收<br>这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器（hub）</li><li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA&#x2F;CD协议，并共享逻辑上的总线。</li><li>集线器很像一个多接口的转发器，工作在物理层</li></ul><h4 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h4><p>以太网的信道被占用的情况：<br>争用期长度为2τ,即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>帧长为L(bit),数据发送速率为C(b&#x2F;s),因而帧的发送时间为L&#x2F;C&#x3D;T0(s)。</p><h4 id="对以太网参数的要求"><a href="#对以太网参数的要求" class="headerlink" title="对以太网参数的要求"></a>对以太网参数的要求</h4><ul><li>当数据率一定时，以太网的连线的长度受到限制，否则τ的数值会太大</li><li>以太网的帧长不能太短，否则T0的值会太小，使a值太大。</li></ul><h4 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h4><p>Smax&#x3D;T0&#x2F;T0+τ&#x3D;1&#x2F;1+a</p><h3 id="MAC层（ipconfig-x2F-all）"><a href="#MAC层（ipconfig-x2F-all）" class="headerlink" title="MAC层（ipconfig &#x2F;all）"></a>MAC层（ipconfig &#x2F;all）</h3><p>在局域网中，硬件地址又称物理地址，或者MAC地址</p><h4 id="发往本站的帧包括以下三种帧"><a href="#发往本站的帧包括以下三种帧" class="headerlink" title="发往本站的帧包括以下三种帧"></a>发往本站的帧包括以下三种帧</h4><ul><li>单播帧（一对一）</li><li>广播帧（一对全体）</li><li>多播帧（一对多）</li></ul><h4 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h4><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>数据字段的长度不在46-1500字节之间（有效的MAC帧长度为64-1518字节之间）</li></ul><p>对于检查出的无效MAC帧就简单丢弃，以太网不负责重传丢弃的帧</p><h4 id="帧的最小间隔"><a href="#帧的最小间隔" class="headerlink" title="帧的最小间隔"></a>帧的最小间隔</h4><p>帧的最小间隔为9.6μs，相当于96bit的发送时间，为了接收数据帧的站的接收缓存来得及清理</p><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="在物理层考虑扩展"><a href="#在物理层考虑扩展" class="headerlink" title="在物理层考虑扩展"></a>在物理层考虑扩展</h4><p>主机使用光纤和一对光线调制解调器连接到集线器</p><p>100BASE-T以太网又称为快速以太网</p><p>速率达到或者超过100Mb&#x2F;s的以太网称为高速以太网</p><p>100BASE-T以太网的物理层</p><ul><li>100BASE-TX:使用2对UTP5类线或屏蔽双绞线STP。</li><li>100BASE-FX:使用2对光纤。</li><li>100BASE-T4:使用4对UTP3类线或5类线。</li></ul><p>100BASE-T特点</p><p>可在全双工方式下工作而无冲突发生。因此，不使用CSMA&#x2F;CD协议<br>MAC帧格式仍然是802.3标准规定的。<br>保持最短帧长不变，但将一个网段的最大电缆长度减小到100m。帧间时间间隔从原来的9.6μs改为现在的0.96μs。</p><p>吉比特以太网的物理层</p><p>1000BASE-X基于光纤通道的物理层</p><ul><li>1000BASE-SX    SX表示短波长</li><li>1000BASE-LX    LX表示长波长</li><li>1000BASE-CX  CX表示铜线</li></ul><p>1000BASE-T</p><ul><li>使用4对5类线UTP</li></ul><h4 id="在数据链路层考虑扩展"><a href="#在数据链路层考虑扩展" class="headerlink" title="在数据链路层考虑扩展"></a>在数据链路层考虑扩展</h4><p>使用网桥，根据MAC帧的目的地址对收到的帧进行转发。</p><p>网桥具有过滤帧的功能。当网桥接收到一个帧时，并不是向所有的接口转发此帧，二十先检查此帧的目的MAC地址，然后再确定将该帧转发到哪个接口</p><p>网桥的好与坏</p><p>好</p><ul><li>过滤通信量。</li><li>扩大了物理范围。</li><li>提高了可靠性。</li><li>可互连不同物理层、不同MAC子层和不同速率（如10M6&#x2F;s和100Mb&#x2F;s以太网)的局域网。</li></ul><p>坏</p><ul><li>存储转发增加了时延。</li><li>在MAC子层并没有流量控制功能。</li><li>具有不同MAC子层的网段桥接在一起时时延更大。</li><li>网桥只适合于用户数不太多（不超过几百个）和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</li></ul><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><h4 id="LAN和VLAN"><a href="#LAN和VLAN" class="headerlink" title="LAN和VLAN"></a>LAN和VLAN</h4><p>LAN：局域网，由交换机或者集线器连着多台计算机</p><p>一个VLAN&#x3D;一个广播域&#x3D;逻辑网段（子网）</p><p>VLAN优点：</p><ul><li>分段</li><li>灵活性</li><li>安全性</li></ul><p>VLAN跨交换机的网段</p><ul><li>干道端口：可以跑多个VLAN数据</li><li>Access端口：接计算机</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><ol><li>网络层向传输层提供的服务<ul><li>虚电路服务<br>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。<br>请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</li><li>数据报服务<br>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每一个分组（即P数据报）独立发送，与其前后的分组无关（不进行编号）。<br>网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。<br>尽最大努力交付的好处：<br>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）<br>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）<br>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。<br>因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></li><li>可靠交付由端系统负责</li></ol><h3 id="虚电路服务和数据报服务的对比"><a href="#虚电路服务和数据报服务的对比" class="headerlink" title="虚电路服务和数据报服务的对比"></a>虚电路服务和数据报服务的对比</h3><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><h4 id="虚拟互联网"><a href="#虚拟互联网" class="headerlink" title="虚拟互联网"></a>虚拟互联网</h4><p>网络互连的设备</p><p>中间设备又称为中间系统或中继(relay)系统。</p><ul><li>物理层中继系统：转发器(repeater)。</li><li>数据链路层中继系统：网桥或桥接器(br idge)。</li><li>网络层中继系统：路由器(router)。</li><li>网络层以上的中继系统：网关(gateway)。</li></ul><p>网关就是路由器接口的地址</p><h4 id="IP协议简介"><a href="#IP协议简介" class="headerlink" title="IP协议简介"></a>IP协议简介</h4><p>网际协议IP是TCP&#x2F;IP体系中两个最主要的协议之一。与IP协议<br>配套使用的还有四个协议：</p><ul><li>地址解析协议ARP(Address Resolution Protocol)</li><li>逆地址解析协议RARP(Reverse Address Resolution Protoco）</li><li>网际控制报文协议ICMP(Internet Control Message Protoco）</li><li>网际组管理协议IGMP(Internet Group Management Protocol）</li></ul><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><h5 id="IP层次结构"><a href="#IP层次结构" class="headerlink" title="IP层次结构"></a>IP层次结构</h5><p>层次化IP地址：将32位的IP地址分为网络ID和主机ID</p><h5 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h5><table><thead><tr><th>网络类别</th><th>最大网络数</th><th>第一个可用的网络号</th><th>最后一个可用的网络号</th><th>每个网络中最大的主机数</th></tr></thead><tbody><tr><td>A</td><td>126（2^7-2)</td><td>1</td><td>126</td><td>16777214</td></tr><tr><td>B</td><td>16383（2^14-1)</td><td>128.1</td><td>191.255</td><td>65534</td></tr><tr><td>C</td><td>2097151（2^21-1)</td><td>192.0.1</td><td>232.255.255</td><td>254</td></tr></tbody></table><h5 id="特殊的几个地址"><a href="#特殊的几个地址" class="headerlink" title="特殊的几个地址"></a>特殊的几个地址</h5><ol><li>127.0.0.1本地环回地址</li><li>169.254.0.0计算机自己给自己产生的临时地址</li><li>主机号不能全0</li><li>主机号全1代表广播，网络中所有计算机都能收到数据包</li></ol><h5 id="保留的私网地址"><a href="#保留的私网地址" class="headerlink" title="保留的私网地址"></a>保留的私网地址</h5><ol><li>10.0.0.0企业政府学校来用</li><li>172.16.0.0 —172.31.0.0</li><li>192.168.0.0 —192.168.255.0</li></ol><h4 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h4><p>子网掩码与自己的IP地址做与运算使主机位归零，看自己与目标主机是否在同一个网段，若源主机与目标主机在一个网段则通，否则交由网关给路由器转发</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><h5 id="等分成2个子网"><a href="#等分成2个子网" class="headerlink" title="等分成2个子网"></a>等分成2个子网</h5><p>每个子网是原来的1&#x2F;2，子网掩码往后移一位</p><p>子网掩码255.255.255.128，网关是192.168.0.1和192.168.0.129</p><h5 id="等分成4个子网"><a href="#等分成4个子网" class="headerlink" title="等分成4个子网"></a>等分成4个子网</h5><p>每个子网是原来的1&#x2F;2×1&#x2F;2，子网掩码往后移两位</p><p>子网掩码255.255.255.192</p><h5 id="等分成8个子网"><a href="#等分成8个子网" class="headerlink" title="等分成8个子网"></a>等分成8个子网</h5><p>每个子网是原来的1&#x2F;2×1&#x2F;2×1&#x2F;2，子网掩码往后移三位</p><p>子网掩码255.255.255.224</p><p><strong>乘了几次1&#x2F;2，子网掩码就往后移几位</strong></p><h5 id="点到点网络"><a href="#点到点网络" class="headerlink" title="点到点网络"></a>点到点网络</h5><p>子网掩码是255.255.255.252，子网掩码往后移6位</p><p><strong>等分的时候每一截子网掩码都一样，不等分时子网掩码不一样</strong></p><h4 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h4><p>让两个子网的计算机划分在一个网段</p><h5 id="合并网络的规律"><a href="#合并网络的规律" class="headerlink" title="合并网络的规律"></a>合并网络的规律</h5><p>向左移动1位子网掩码可以合并0、1网络，也可以合并2、3网络，也可以合并4、5网络，也可以合并6、7网络<br>通过向左移动2位子网掩码可以将连续的0、1、2、3网络合并成一个网络，也可将连续的4、5、6、7网络合并成一个网络<br>通过向左移动3位子网掩码，可以将0、1、2、3、4、5、6、7网络合并成一个网络</p><h4 id="IP地址与MAC硬件地址"><a href="#IP地址与MAC硬件地址" class="headerlink" title="IP地址与MAC硬件地址"></a>IP地址与MAC硬件地址</h4><h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><p>数据+IP地址（包括目标地址和源地址）</p><h5 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h5><p>数据包+MAC地址，MAC地址每过一个网络设备就就得变一次</p><h5 id="IP地址与MAC地址的区别"><a href="#IP地址与MAC地址的区别" class="headerlink" title="IP地址与MAC地址的区别"></a>IP地址与MAC地址的区别</h5><ul><li>IP地址决定了数据包最终要到哪个计算机</li><li>MAC地址决定了下一跳给谁，即下一个设备给谁</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h4 id="ARP协议工作机制"><a href="#ARP协议工作机制" class="headerlink" title="ARP协议工作机制"></a>ARP协议工作机制</h4><p>ARP协议负责把IP地址解析成MAC地址，解析靠广播</p><h4 id="判定ARP欺骗"><a href="#判定ARP欺骗" class="headerlink" title="判定ARP欺骗"></a>判定ARP欺骗</h4><h5 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h5><p>一台计算机恶意覆盖网关地址，获取其他计算机发给路由器的数据信息</p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p>arp -a</p><h4 id="逆地址解析协议RARP"><a href="#逆地址解析协议RARP" class="headerlink" title="逆地址解析协议RARP"></a>逆地址解析协议RARP</h4><p>逆地址解析协议RARP使只知道自己硬件地址的主机能够知道其IP地址。</p><h3 id="数据包-1"><a href="#数据包-1" class="headerlink" title="数据包"></a>数据包</h3><h4 id="数据包首部"><a href="#数据包首部" class="headerlink" title="数据包首部"></a>数据包首部</h4><p><strong>一个IP数据报由首部和数据两部分组成</strong></p><ul><li>首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><h4 id="IP数据报首部的固定部分中的各字段"><a href="#IP数据报首部的固定部分中的各字段" class="headerlink" title="IP数据报首部的固定部分中的各字段"></a>IP数据报首部的固定部分中的各字段</h4><ol><li><p>版本</p><p>占四位，指IP协议的版本（IPv4还是IPv6）</p></li><li><p>首部长度</p><p>占四位，可表示的最大数值是15个单位（一个单位为4字节）</p></li><li><p>区分服务</p><p> 占八位，用来获取更好的服务，区分服务的轻重缓急，路由器端也要配有区分服务才能使用</p></li><li><p>总长度</p><p>占16位，指首部和数据之和的长度</p></li><li><p>标识</p><p>占16位，计数器，用来产生数据报的标识</p></li><li><p>标志</p><p>区别包是否分片</p></li><li><p>片偏移</p><p>表示偏移量</p></li><li><p>生存时间</p><p>记为TTL，数据报在网路中可通过的路由器数的最大值</p></li><li><p>协议</p><p>(8位)字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程</p></li><li><p>首部校验和</p><p>(16位)字段只检验数据报的首部，不检验数据部分。这里不采用CRC检验码而采用简单的计算方法</p></li></ol><h4 id="IP数据报首部的可变部分"><a href="#IP数据报首部的可变部分" class="headerlink" title="IP数据报首部的可变部分"></a>IP数据报首部的可变部分</h4><ul><li>IP首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</li><li>选项字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。</li><li>错加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。</li></ul><h3 id="IP转发分组的流程"><a href="#IP转发分组的流程" class="headerlink" title="IP转发分组的流程"></a>IP转发分组的流程</h3><h4 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h4><p>路由器在不同网段转发数据包</p><h4 id="网络畅通的条件"><a href="#网络畅通的条件" class="headerlink" title="网络畅通的条件"></a>网络畅通的条件</h4><p>能去能回</p><ul><li>沿途的路由器必须知道到目标网络下一跳给哪个接口</li><li>沿途的路由器必须知道到源网络下一跳给哪个接口</li></ul><p><strong>管理员给路由器加路由表时，告诉路由器没有直连的所有网络怎么走，叫做静态路由，配完后才能通</strong></p><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><ul><li>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间太小并没有得到充分使用，而因特网的P地址仍在加速消耗，整个PV4地址空间面临全部耗尽的威胁。</li><li>为此，因特网工程任务组ETF又提出了采用无分类编址的方法来解决P地址紧张的问题，同时还专门成立PV6工作组负责研究新版本P以彻底解决P地址耗尽问题。</li><li>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-.Domain Routing)的RFC文档：RFC1517~1519和1520。</li><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念；</li><li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的1PV6使用之前允许因特网<br>的规模继续增长。</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li>CIDR使用“斜线记法”，或称CIDR记法。即在IPV4地址后面加上斜线“&#x2F;”，在斜线后面写上网络前缀所占的比特数量。</li><li>CIDR实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址块”。</li><li>我们只要知道CDR地址块中的任何一个地址，就可以知道该地址块的全部细节：<ul><li>地址块的最小地址</li><li>地址块的最大地址</li><li>地址块中的地址数量</li><li>地址块聚合某类网络(A类、B类或C类)的数量</li><li>地址掩码（也可继续称为子网掩码）</li></ul></li></ol><h4 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h4><ol><li>网络前缀越长，地址块越小，路由越具体；</li><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配，因为这样的路由更具体。</li><li>网络地址&#x3D;网络前缀+主机号全0</li><li>广播地址&#x3D;网络前缀+主机号全1</li></ol><h3 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><p>IP数据报的发送和转发过程包含以下两部分：</p><ul><li>主机发送IP数据报</li><li>路由器转发P数据报</li></ul><p>为了将重点放在TCP&#x2F;八P协议栈的网际层发送和转发IP数据报的过程上，在之后的举例中，我们忽略使用ARP协议来获取目的主机或路由器接口的MAC地址的过程以及以太网交换机自学习和转发帧的过程。</p><h4 id="直接交付"><a href="#直接交付" class="headerlink" title="直接交付"></a>直接交付</h4><p>同一个网络中的主机间可以直接通信</p><h4 id="间接交付"><a href="#间接交付" class="headerlink" title="间接交付"></a>间接交付</h4><p>不同网络中的主机通信，通过路由器进行中转</p><h4 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h4><p>当本网络中的主机要和其他网络中的主机进行通信时，会将IP数据报传输给默认网关，由默认网关帮主机将IP数据报转发出去</p><h4 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h4><p><strong>路由器收到IP数据报后如何转发？</strong></p><ol><li><p>检查IP数据报首部是否出错：</p><ul><li>若出错，则直接丢弃该P数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li><p>根据P数据报的目的地址在路由表中查找匹配的条目：</p><ul><li><p>若找到匹配的条目，则转发给条目中指示的下一跳</p></li><li><p>若找不到，则丢弃该P数据报并通告源主机</p></li></ul></li></ol><h3 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h3><ol><li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。<ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化。</li><li>一般只在小规模网络中采用。</li></ul></li><li>使用静态路由配置可能出现以下导致产生路由环路的错误<ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaEE</title>
      <link href="/2023/05/29/2023-5-29-javaEE/"/>
      <url>/2023/05/29/2023-5-29-javaEE/</url>
      
        <content type="html"><![CDATA[<h2 id="javaEE笔记"><a href="#javaEE笔记" class="headerlink" title="javaEE笔记"></a>javaEE笔记</h2><h3 id="遇到的问题一"><a href="#遇到的问题一" class="headerlink" title="遇到的问题一"></a>遇到的问题一</h3><p>在idea中右击新建没有servlet选项</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>点击文件当中的项目结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291639421.png" alt="image-20230529163938335"></p><p>在Facet中找到该项目，在源根中勾选两个选项，点击确定</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291641522.png" alt="image-20230529164134434"></p><p>至此，返回对应的文件夹，右击新建即可看到servlet选项</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291642126.png" alt="image-20230529164251990"></p>]]></content>
      
      
      <categories>
          
          <category> javaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理</title>
      <link href="/2023/05/24/2023-5-24-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/24/2023-5-24-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h2><h3 id="数据库的四个基本概念"><a href="#数据库的四个基本概念" class="headerlink" title="数据库的四个基本概念"></a>数据库的四个基本概念</h3><p>数据是数据库中存储的基本对象</p><h4 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h4><p>描述事物的符号记录</p><h4 id="数据的种类"><a href="#数据的种类" class="headerlink" title="数据的种类"></a>数据的种类</h4><p>文字、图形、图像、声音、数字、视频等</p><h4 id="数据的特点"><a href="#数据的特点" class="headerlink" title="数据的特点"></a>数据的特点</h4><p>数据与语义是不可分的</p><h4 id="计算机记录"><a href="#计算机记录" class="headerlink" title="计算机记录"></a>计算机记录</h4><p>记录是计算机中表示和存储数据的一种形式</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>长期存储在计算机内、有组织的、可共享的大量数据的集合</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余性较小</li><li>数据独立性高</li><li>易扩展</li></ul><h3 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>位于用户与操作系统之间的一层数据管理软件</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>科学地组织和存储数据、高效地获取和维护数据</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="数据定义功能"><a href="#数据定义功能" class="headerlink" title="数据定义功能"></a>数据定义功能</h5><p>DBMS提高数据定义语言（DDL）对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织、存储和管理"><a href="#数据组织、存储和管理" class="headerlink" title="数据组织、存储和管理"></a>数据组织、存储和管理</h5><p>提高存储空间利用率和方便存取，提供多种存取方法（索引查找、hash查找、顺序查找等）提高存取效率</p><h5 id="数据操纵功能"><a href="#数据操纵功能" class="headerlink" title="数据操纵功能"></a>数据操纵功能</h5><p>DBMS提高数据操作语言（DML）操纵数据实现对数据库的基本操作（增删改查）</p><h5 id="数据库的事物管理和运行管理"><a href="#数据库的事物管理和运行管理" class="headerlink" title="数据库的事物管理和运行管理"></a>数据库的事物管理和运行管理</h5><p>保证数据的安全性、完整性、多用户对数据的并发使用、发生故障后的系统恢复</p><h5 id="数据库的建立和维护功能"><a href="#数据库的建立和维护功能" class="headerlink" title="数据库的建立和维护功能"></a>数据库的建立和维护功能</h5><p>数据库数据批量装载、数据库转储、介质故障恢复、数据库的重组织以及性能监视</p><h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><p>与网络中的其他软件系统的通信功能，数据转换功能，异构数据库之间的互访和互操功能等</p><h3 id="数据库系统（DBS）"><a href="#数据库系统（DBS）" class="headerlink" title="数据库系统（DBS）"></a>数据库系统（DBS）</h3><p>由数据库、数据库管理系统（及应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>概念模型也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。</li><li>数据模型主要包括网状模型、层次模型、关系模型等，它是按计算机系统的观点对数据进行建模，描述数据在系统内部的表示方式和存取方法。</li></ul><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><ul><li>实体（Entity）：客观存在并可相互区别的事物成为实体，可以是具体的人、事、物或抽象的概念。</li><li>属性(Attribute)：实体所具有的某一特性称为属性，一个实体可以由若干个属性来刻画。</li><li>码(Key)：唯一标识实体的属性集称为码。</li><li>域(Domain)：属性的取值范围称为该属性的域。</li><li>实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体称为实体型。</li><li>实体集(Entity Set)：同型实体的集合称实体集。</li><li>联系(Relationship)：现实世界中事物内部及其事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。</li></ul><h5 id="两个实体之间的联系"><a href="#两个实体之间的联系" class="headerlink" title="两个实体之间的联系"></a>两个实体之间的联系</h5><ol><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ol><h5 id="实体表示方法：E-R图"><a href="#实体表示方法：E-R图" class="headerlink" title="实体表示方法：E-R图"></a>实体表示方法：E-R图</h5><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121834929.png" alt="image-20230612183423816"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121835769.png" alt="image-20230612183500671"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121835276.png" alt="image-20230612183536146"></p><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>描述数据库的组成对象以及对象之间的联系。一类是对象的类型内容等；一类是对象之间的关系。</p><h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><p>对数据库中各种对象的实例允许执行操作的集合</p><h5 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h5><p>数据及其联系所具有的制约和依存规则</p><h4 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h4><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>层次模型数据结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121923197.png" alt="image-20230612192350095"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121924638.png" alt="image-20230612192454540"></p><p> <img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121926474.png" alt="image-20230612192624372"></p><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>网状模型数据结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121932660.png" alt="image-20230612193246557"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306121951255.png" alt="image-20230612195148170"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#</title>
      <link href="/2023/05/14/2023-5-14-C/"/>
      <url>/2023/05/14/2023-5-14-C/</url>
      
        <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>值类型的数据结构，单一变量存储各种数据类型。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>struct关键字创建</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.可定义构造函数，不能定义析构函数和无参构造函数</p><p>2.不能继承其他结构或者类，但是可以实验一个或者多个接口</p><p>3.结构成员不能指定为abstract、virtual、protected</p><p>4.可以不使用New操作符进行实例化</p><h4 id="结构与类的比较"><a href="#结构与类的比较" class="headerlink" title="结构与类的比较"></a>结构与类的比较</h4><p>1.类是引用类型，结构是值类型</p><p>2.结构不能声明无参构造函数</p><p>3，结构不支持继承</p><p>4.结构中声明的字段无法赋予初值</p><p>5.结构体的构造函数中，必须为结构体所有字段赋值</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>值类型，一组命名整型常量</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>enum关键字声明</p><h4 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> &lt;enum_name&gt;</span><br><span class="line">&#123;</span><br><span class="line">    enumeration list</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>enum_name指定枚举类型的名称</li><li>enumeration list是一个用逗号分隔的标识符列表</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是0</p><p>2.不能继承和传递继承</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>以关键字class开始，后跟类的名称。类的主体，包含在一对花括号内。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span>  <span class="title">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// member variables</span></span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    <span class="comment">// member methods</span></span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>访问标识符<code>&lt;access specifier&gt;</code>指定了对类和成员的访问规则，默认情况下，类的访问标识符是<code>internal</code>，成员的访问标识符是<code>private</code></li><li><code>&lt;data type&gt;</code>指定了变量的类型，<code>&lt;return type&gt;</code>指定了返回方法的数据类型</li><li>点运算符链接了对象的名称和成员的名称</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>类的特殊成员函数，当创建类的新对象执行，名称与类的名称完全相同，没有任何返回类型</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>类的特殊成员函数，当类的对象超出范围时执行。</p><p>在类的名称前加上一个波浪号（~)作为前缀，不返回值，也不带任何参数</p><p>用于在结束程序（关闭文件、释放内存）之前释放资源。</p><p>不能继承和重载</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>static关键字定义类成员</p><p>用于定义常量，直接调用类而不需要创建类的实例获取</p><p>在成员函数或类的定义外部初始化，也可以在类的定义内部初始化静态变量</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的<strong>基类</strong>，这个新的类被称为<strong>派生类</strong></p><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;访问修饰符&gt; <span class="keyword">class</span> &lt;基类&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> &lt;派生类&gt; : &lt;基类&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p><strong>C# 不支持多重继承</strong>。但是可以使用接口来实现多重继承。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>同一个接口，使用不同的实例而执行不同操作</p><h4 id="静态多态性"><a href="#静态多态性" class="headerlink" title="静态多态性"></a>静态多态性</h4><ul><li>函数重载</li><li>运算符重载</li></ul><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在同一个范围内对相同的函数名有多个定义，可以是参数列表中的<strong>参数类型</strong>不同，也可以是<strong>参数个数</strong>不同，不能只有返回类型不同的函数声明</p><h4 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h4><p>使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ul><li>不能创建抽象类的实例</li><li>不能在一个抽象类外部声明一个抽象方法</li><li>在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。</li></ul><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用<strong>虚方法</strong></p><p>使用关键字 <strong>virtual</strong> 声明，在不同的继承类中有不同的实现</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>可以重定义或重载 C# 中内置的运算符，具有特殊名称的函数</p><p>关键字 <strong>operator</strong> 后跟运算符的符号来定义</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OperatorOvlApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">     </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getVolume</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBreadth</span>(<span class="params"> <span class="built_in">double</span> bre </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"> <span class="built_in">double</span> hei </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载 + 运算符来把两个 Box 对象相加</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">      &#123;</span><br><span class="line">          Box box = <span class="keyword">new</span> Box();</span><br><span class="line">          box.length = b.length + c.length;</span><br><span class="line">          box.breadth = b.breadth + c.breadth;</span><br><span class="line">          box.height = b.height + c.height;</span><br><span class="line">          <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> == (Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length == rhs.length &amp;&amp; lhs.height == rhs.height</span><br><span class="line">             &amp;&amp; lhs.breadth == rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length != rhs.length || lhs.height != rhs.height</span><br><span class="line">              || lhs.breadth != rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &lt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length &lt; rhs.length &amp;&amp; lhs.height</span><br><span class="line">              &lt; rhs.height &amp;&amp; lhs.breadth &lt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &gt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length &gt; rhs.length &amp;&amp; lhs.height</span><br><span class="line">              &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &lt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length &lt;= rhs.length &amp;&amp; lhs.height</span><br><span class="line">              &lt;= rhs.height &amp;&amp; lhs.breadth &lt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &gt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (lhs.length &gt;= rhs.length &amp;&amp; lhs.height</span><br><span class="line">             &gt;= rhs.height &amp;&amp; lhs.breadth &gt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> String.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;</span>, length, breadth, height);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">class</span> <span class="title">Tester</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">        Box Box1 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">        Box Box2 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">        Box Box3 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">        Box Box4 = <span class="keyword">new</span> Box();</span><br><span class="line">        <span class="built_in">double</span> volume = <span class="number">0.0</span>;   <span class="comment">// 体积</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Box1 详述</span></span><br><span class="line">        Box1.setLength(<span class="number">6.0</span>);</span><br><span class="line">        Box1.setBreadth(<span class="number">7.0</span>);</span><br><span class="line">        Box1.setHeight(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Box2 详述</span></span><br><span class="line">        Box2.setLength(<span class="number">12.0</span>);</span><br><span class="line">        Box2.setBreadth(<span class="number">13.0</span>);</span><br><span class="line">        Box2.setHeight(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用重载的 ToString() 显示两个盒子</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box1： &#123;0&#125;&quot;</span>, Box1.ToString());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box2： &#123;0&#125;&quot;</span>, Box2.ToString());</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// Box1 的体积</span></span><br><span class="line">        volume = Box1.getVolume();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box1 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Box2 的体积</span></span><br><span class="line">        volume = Box2.getVolume();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box2 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把两个对象相加</span></span><br><span class="line">        Box3 = Box1 + Box2;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box3： &#123;0&#125;&quot;</span>, Box3.ToString());</span><br><span class="line">        <span class="comment">// Box3 的体积</span></span><br><span class="line">        volume = Box3.getVolume();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Box3 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//comparing the boxes</span></span><br><span class="line">        <span class="keyword">if</span> (Box1 &gt; Box2)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 大于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 不大于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Box1 &lt; Box2)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 小于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 不小于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Box1 &gt;= Box2)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 大于等于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 不大于等于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Box1 &lt;= Box2)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 小于等于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 不小于等于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Box1 != Box2)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 不等于 Box2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box1 等于 Box2&quot;</span>);</span><br><span class="line">        Box4 = Box3;</span><br><span class="line">        <span class="keyword">if</span> (Box3 == Box4)</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box3 等于 Box4&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Box3 不等于 Box4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Box1： (6, 7, 5)</span><br><span class="line">Box2： (12, 13, 10)</span><br><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br><span class="line">Box3： (18, 20, 15)</span><br><span class="line">Box3 的体积： 5400</span><br><span class="line">Box1 不大于 Box2</span><br><span class="line">Box1 小于 Box2</span><br><span class="line">Box1 不大于等于 Box2</span><br><span class="line">Box1 小于等于 Box2</span><br><span class="line">Box1 不等于 Box2</span><br><span class="line">Box3 等于 Box4</span><br></pre></td></tr></table></figure><h4 id="可重载和不可重载运算符"><a href="#可重载和不可重载运算符" class="headerlink" title="可重载和不可重载运算符"></a>可重载和不可重载运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+, -, !, ~, ++, –</td><td>这些一元运算符只有一个操作数，且可以被重载。</td></tr><tr><td>+, -, *, &#x2F;, %</td><td>这些二元运算符带有两个操作数，且可以被重载。</td></tr><tr><td>&#x3D;&#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;</td><td>这些比较运算符可以被重载。</td></tr><tr><td>&amp;&amp;, ||</td><td>这些条件逻辑运算符不能被直接重载。</td></tr><tr><td>+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;</td><td>这些赋值运算符不能被重载。</td></tr><tr><td>&#x3D;, ., ?:, -&gt;, new, is, sizeof, typeof</td><td>这些运算符不能被重载。</td></tr></tbody></table><h4 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h4><ul><li>运算符只能采用值参数，不能采用 ref 或 out 参数</li><li>要求成对重载比较运算符。如果重载了&#x3D;&#x3D;，则也必须重载!&#x3D;，否则产生编译错误。比较运算符必须返回bool类型的值</li><li>不允许重载&#x3D;运算符，但如果重载例如+运算符，编译器会自动使用+运算符的重载来执行+&#x3D;运算符的操作</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分</p><p>使得实现接口的类或结构在形式上保持一致</p><p>接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约</p><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><p>使用 <strong>interface</strong> 关键字声明,与类的声明类似。接口声明默认是 public 的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p>以关键字 <strong>namespace</strong> 开始，后跟命名空间的名称</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h4><p><strong>using</strong> 关键字表明程序使用的是给定命名空间中的名称</p><p>使用 <strong>using</strong> 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> first_space;</span><br><span class="line"><span class="keyword">using</span> second_space;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">first_space</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">abc</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Inside first_space&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">second_space</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">efg</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Inside second_space&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      abc fc = <span class="keyword">new</span> abc();</span><br><span class="line">      efg sc = <span class="keyword">new</span> efg();</span><br><span class="line">      fc.func();</span><br><span class="line">      sc.func();</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h4><p>命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name1</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">   <span class="keyword">namespace</span> <span class="title">namespace_name2</span> </span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 代码声明</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用点（.）运算符访问嵌套的命名空间的成员</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> SomeNameSpace;</span><br><span class="line"><span class="keyword">using</span> SomeNameSpace.Nested;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SomeNameSpace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;In SomeNameSpace&quot;</span>);</span><br><span class="line">            Nested.NestedNameSpaceClass.SayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内嵌命名空间</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Nested</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NestedNameSpaceClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;In Nested&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>在程序执行期间出现的问题</p><p>提供了一种把程序控制权从某个部分转移到另一个部分的方式</p><p>关键字：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong> 和 <strong>throw</strong></p><ul><li><strong>try</strong>：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。</li><li><strong>catch</strong>：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。</li><li><strong>finally</strong>：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。</li><li><strong>throw</strong>：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 引起异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>C# 中的异常类主要是直接或间接地派生于 <strong>System.Exception</strong> 类</p><p><strong>System.ApplicationException</strong> 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。</p><p><strong>System.SystemException</strong> 类是所有预定义的系统异常的基类。</p><h4 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ErrorHandlingApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DivNumbers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        DivNumbers()</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">division</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (DivideByZeroException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception caught: &#123;0&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DivNumbers d = <span class="keyword">new</span> DivNumbers();</span><br><span class="line">            d.division(<span class="number">25</span>, <span class="number">0</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception caught: System.DivideByZeroException: 尝试除以零。</span><br><span class="line">   在 finalReview.DivNumbers.division(Int32 num1, Int32 num2) 位置 D:\QQ\1766522495\.net应用开发技术\C#\finalReview\finalReview\Program.cs:行号 17</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure><h4 id="创建用户自定义异常"><a href="#创建用户自定义异常" class="headerlink" title="创建用户自定义异常"></a>创建用户自定义异常</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserDefinedException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">TestTemperature</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Temperature temp = <span class="keyword">new</span> Temperature();</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">            temp.showTemp();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span>(TempIsZeroException e)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;TempIsZeroException: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TempIsZeroException</span>: <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TempIsZeroException</span>(<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Temperature</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">int</span> temperature = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTemp</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(temperature == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">throw</span> (<span class="keyword">new</span> TempIsZeroException(<span class="string">&quot;Zero Temperature found&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Temperature: &#123;0&#125;&quot;</span>, temperature);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TempIsZeroException: Zero Temperature found</span><br></pre></td></tr></table></figure><h3 id="文件的输入与输出"><a href="#文件的输入与输出" class="headerlink" title="文件的输入与输出"></a>文件的输入与输出</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>一个存储在磁盘中带有指定名称和目录路径的数据集合</p><p>当打开文件进行读写时，它变成一个 <strong>流</strong>，从根本上说，流是通过通信路径传递的字节序列</p><p>两个主要的流：<strong>输入流</strong> 和 <strong>输出流</strong>。</p><p><strong>输入流</strong>用于从文件读取数据（读操作）</p><p><strong>输出流</strong>用于向文件写入数据（写操作）</p><table><thead><tr><th>I&#x2F;O类</th><th>描述</th></tr></thead><tbody><tr><td>BinaryReader</td><td>从二进制流读取原始数据。</td></tr><tr><td>BinaryWriter</td><td>以二进制格式写入原始数据。</td></tr><tr><td>BufferedStream</td><td>字节流的临时存储。</td></tr><tr><td>Directory</td><td>有助于操作目录结构。</td></tr><tr><td>DirectoryInfo</td><td>用于对目录执行操作。</td></tr><tr><td>DriveInfo</td><td>提供驱动器的信息。</td></tr><tr><td>File</td><td>有助于处理文件。</td></tr><tr><td>FileInfo</td><td>用于对文件执行操作。</td></tr><tr><td>FileStream</td><td>用于文件中任何位置的读写。</td></tr><tr><td>MemoryStream</td><td>用于随机访问存储在内存中的数据流。</td></tr><tr><td>Path</td><td>对路径信息执行操作。</td></tr><tr><td>StreamReader</td><td>用于从字节流中读取字符。</td></tr><tr><td>StreamWriter</td><td>用于向一个流中写入字符。</td></tr><tr><td>StringReader</td><td>用于读取字符串缓冲区。</td></tr><tr><td>StringWriter</td><td>用于写入字符串缓冲区。</td></tr></tbody></table><h4 id="FileStream类"><a href="#FileStream类" class="headerlink" title="FileStream类"></a>FileStream类</h4><p>创建一个 <strong>FileStream</strong> 对象来创建一个新的文件，或打开一个已有的文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileStream &lt;object_name&gt; = <span class="keyword">new</span> FileStream( &lt;file_name&gt;,</span><br><span class="line">&lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>FileMode：枚举定义了各种打开文件的方法</p><ul><li><strong>Append</strong>：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。</li><li><strong>Create</strong>：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。</li><li><strong>CreateNew</strong>：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。</li><li><strong>Open</strong>：打开一个已有的文件。如果文件不存在，则抛出异常。</li><li><strong>OpenOrCreate</strong>：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。</li><li><strong>Truncate</strong>：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。</li></ul><p>FileAccess：枚举的成员有：<strong>Read</strong>、<strong>ReadWrite</strong> 和 <strong>Write</strong>。</p><p>FileShare</p><ul><li><strong>Inheritable</strong>：允许文件句柄可由子进程继承。Win32 不直接支持此功能。</li><li><strong>None</strong>：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。</li><li><strong>Read</strong>：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</li><li><strong>ReadWrite</strong>：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</li><li><strong>Write</strong>：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</li><li><strong>Delete</strong>：允许随后删除文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2023/05/07/2023-5-7-%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/07/2023-5-7-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h4><h5 id="手写一个堆"><a href="#手写一个堆" class="headerlink" title="手写一个堆"></a>手写一个堆</h5><p>假设size表示堆的大小，heap表示当前堆</p><p>①插入一个数：heap[++size]&#x3D;x;up(size);</p><p>②求集合中的最小值:heap[1];</p><p>③删除最小值:heap[1]&#x3D;heap[size];size–;down(1);</p><p>④删除任意一个元素:heap[k]&#x3D;heap[size];size–;down(k);up(k);</p><p>⑤修改任意一个元素heap[k]&#x3D;x;down(k);up(k);</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>一棵完全二叉树，除了最后一层一层结点，上面所有结点都是满的且不存在空的情况，最后一层结点从左到右排列。</p><h5 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h5><p>每个点的值都是小于等于左右儿子的值，因此根节点一定是最小值</p><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><p>用一维数组存，一号点为根节点，结点x的左儿子的下标是2x，右儿子的下标是2x+1</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>down(x):如果一个值变大则下移</p><p>up(x)：如果一个值变小则上移</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建堆，时间复杂度为<span class="built_in">O</span>(n)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)<span class="built_in">down</span>(i);</span><br><span class="line"><span class="meta">#down操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;#最小值的下标</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t])t=u*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    #此时t是最小值的下标</span><br><span class="line">    <span class="keyword">if</span>(u!=t)&#123;#根节点不是最小值</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t)</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/04/23/2023-4-21-%E8%AE%A1%E7%BB%84/"/>
      <url>/2023/04/23/2023-4-21-%E8%AE%A1%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="计算机的发展史"><a href="#计算机的发展史" class="headerlink" title="计算机的发展史"></a>计算机的发展史</h3><p>世界上第一台电子计算机<strong>ENIAC</strong>（1946）</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301253663.png" alt="image-20230530125301506"></p><h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h3><p>计算机系统包括硬件和软件，其中软件又分为系统软件和应用软件</p><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><p>管理整个计算机系统</p><ul><li>语言处理系统 汇编程序 编译程序 解释程序</li><li>操作系统  DOS、UNIX、Windows、Linux、Kylin Linux</li><li>服务性程序 装配 调试 诊断 排错</li><li>数据库管理系统 数据库和数据库管理软件</li><li>网络软件</li></ul><h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><p>按任务需要编制成的各种程序</p><h4 id="软件发展的特点"><a href="#软件发展的特点" class="headerlink" title="软件发展的特点"></a>软件发展的特点</h4><ul><li>开发周期长</li><li>制作成本昂贵</li><li>检测软件产品质量的特殊性</li></ul><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>高级语言   虚拟机器M3   用编译程序翻译成汇编语言程序</p><p>汇编语言   虚拟机器M2   用汇编程序翻译成机器语言程序</p><p>操作系统   虚拟机器   用机器语言解释操作系统</p><hr><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>机器语言   实际机器M1   用微指令解释机器指令</p><p>微指令系统    微程序机器M0   由硬件直接执行微指令</p><h3 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h3><h4 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h4><ol><li>计算机由五大部件组成</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心</li></ol><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291454669.png" alt="image-20230529145413548"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131405299.png" alt="image-20230613140501209"></p><p>存储体-存储单元-存储元件</p><h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5><p>存放一串二进制代码</p><h5 id="存储字"><a href="#存储字" class="headerlink" title="存储字"></a>存储字</h5><p>存储单元中二进制代码的组合</p><h5 id="存储字长"><a href="#存储字长" class="headerlink" title="存储字长"></a>存储字长</h5><p>存储单元中二进制代码的位数</p><p>每个存储单元赋予一个地址</p><p>按地址寻访</p><h5 id="MAR"><a href="#MAR" class="headerlink" title="MAR"></a>MAR</h5><p>存储器地址寄存器</p><p>反映存储单元个数</p><h5 id="MDR"><a href="#MDR" class="headerlink" title="MDR"></a>MDR</h5><p>存储器数据寄存器</p><p>反映存储字长</p><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232223531.png" alt="image-20230423222300470"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232217818.png" alt="image-20230423221751690"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131402393.png" alt="image-20230613140253327"></p><p>主存-辅存：实现虚拟存储系统，解决了主存容量不够的问题</p><p>Cache-主存：解决了主存和CPU速度不匹配的问题</p><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><h5 id="按层次"><a href="#按层次" class="headerlink" title="按层次"></a>按层次<img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232229335.png" alt="image-20230423222924284"></h5><h5 id="按存储介质"><a href="#按存储介质" class="headerlink" title="按存储介质"></a>按存储介质</h5><p>1.半导体存储器：以半导体器件存储信息，读写速度较快，如主存、Cache</p><p>2.磁表面存储器：以磁性材料存储信息，如磁盘、磁带</p><p>3.光存储器：以光介质存储信息，如DVD、VCD</p><h5 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h5><p>1.随机存取存储器（Random Access Memory，RAM):读写任何一个存储单元所需时间都相同，与存储单元所在物理位置无关，如内存条</p><p>2.顺序存取存储器（Sequential Access Memory，SAM):读写一个存储单元所需时间取决于存储单元所在的物理位置，如复读机、录音机</p><p>3.直接存取存储器（Direct Access Memory，DAM):既有随机存取存储器特性，也有顺序存取存储器特性。先直接选取信息所在区域，然后顺序方式存取，速度比SAM快一些，比RAM慢一些，如机械硬盘也就是磁盘</p><p>4.相联存储器（Associative Memory），即可以按内容访问的存储器（Content Addressed Memory，CAM）可以按照内容检索到存储位置进行读写，“快表”就是一种相联存储器</p><p>串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关，如SAM，DAM</p><h5 id="信息的可更改性"><a href="#信息的可更改性" class="headerlink" title="信息的可更改性"></a>信息的可更改性</h5><p>1.读写存储器（Read&#x2F;Write Memory):即可读，也可写（如：磁盘、内存、Cache）</p><p>2.只读存储器（Read Only Memory）：只能读，不能写（如实体音乐专辑通常采用CD-ROM，实体电影采用蓝光光碟，BIOS通常写在ROM中）</p><h5 id="信息的可保存性"><a href="#信息的可保存性" class="headerlink" title="信息的可保存性"></a>信息的可保存性</h5><p>1.易失性存储器：断电后，存储信息消失的存储器（主存、Cache）</p><p>2.非易失性存储器：存储信息依然保持的存储器（磁盘、光盘）</p><p>破坏性读出：信息读出后，原存储信息被破坏（DRAM芯片，读出数据后要进行重写）</p><p>非破坏性读出：信息读出后，原存储信息不被破坏（SRAM芯片，磁盘、光盘）</p><h5 id="按作用分类"><a href="#按作用分类" class="headerlink" title="按作用分类"></a>按作用分类</h5><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131350350.png" alt="image-20230613135009179"></p><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>1.存储容量：存储字数×字长（如1M×8位）（MDR位数反映存储字长）</p><p>2.单位成本：每位价格&#x3D;总成本&#x2F;总容量</p><p>3.存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期（数据的宽度即存储字长）</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232300118.png" alt="image-20230423230020043"></p><h4 id="主存和CPU的联系"><a href="#主存和CPU的联系" class="headerlink" title="主存和CPU的联系"></a>主存和CPU的联系</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131407299.png" alt="image-20230613140741229"></p><h4 id="主存中存储单元地址分配"><a href="#主存中存储单元地址分配" class="headerlink" title="主存中存储单元地址分配"></a>主存中存储单元地址分配</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131413113.png" alt="image-20230613141304002"></p><h4 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h4><p>存储容量：主存存放二进制代码的总位数</p><p>存储速度：</p><ul><li>存储时间：存储器的访问时间：读出&#x2F;写入时间</li><li>存取周期：连续两次独立的存储器操作：（读或写)所需的最小间隔时间</li></ul><p>存储器的带宽：位&#x2F;秒</p><h4 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131434056.png" alt="image-20230613143444970"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131437210.png" alt="image-20230613143703094"></p><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><h4 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232307621.png" alt="image-20230423230748503"></p><h4 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232313063.png" alt="image-20230423231326934"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131423879.png" alt="image-20230613142345779"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131428371.png" alt="image-20230613142830251"></p><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304232324235.png" alt="image-20230423232424137"></p><h3 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h3><p>DRAM（动态RAM）：Dynamic Random Access Memory，用于主存</p><p>SRAM（静态RAM）：Static Random Access Memory，用于Cache</p><p>核心区别：存储元不一样</p><p>DRAM芯片：使用栅极电容存储信息</p><p>SRAM芯片：使用双稳态触发器存储信息</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131443615.png" alt="image-20230613144338505"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202306131459244.png" alt="image-20230613145923126"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304241219598.png" alt="image-20230424121904352"></p><p>由于电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失，因此2ms内必须“刷新”一次（给电容充电）</p><h4 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304241539588.png" alt="image-20230424153945407"></p><h4 id="DRAM和SRAM的对比"><a href="#DRAM和SRAM的对比" class="headerlink" title="DRAM和SRAM的对比"></a>DRAM和SRAM的对比</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304241542807.png" alt="image-20230424154224651"></p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304241548631.png" alt="image-20230424154845459"></p><p>主板上的BIOS芯片（ROM）存储了“自举装入程序”，负责引导装入操作系统（开机）。根据程序，CPU指挥IO系统把辅存中存储的操作系统的相关数据放到主存，引导开机。</p><h3 id="主存与CPU的连接"><a href="#主存与CPU的连接" class="headerlink" title="主存与CPU的连接"></a>主存与CPU的连接</h3><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304251622653.png" alt="image-20230425162218518"></p><h3 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h3><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304261041560.png" alt="image-20230426104127971"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><h4 id="基本组成-1"><a href="#基本组成-1" class="headerlink" title="基本组成"></a>基本组成</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291508871.png" alt="image-20230529150843806"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291518707.png" alt="image-20230529151806640"></p><p>、</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="基本组成-2"><a href="#基本组成-2" class="headerlink" title="基本组成"></a>基本组成</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305291538254.png" alt="image-20230529153834194"></p><p>完成一条指令</p><ul><li>取指令：<strong>PC</strong>（程序计数器）存放当前欲执行指令的地址，具有计数功能（PC）+1-&gt;PC</li><li>分析指令：<strong>IR</strong>（指令寄存器）存放当前欲执行的指令</li><li>执行指令:<strong>CU</strong></li></ul><h3 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h3><h4 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h4><p><strong>CPU</strong>一次能处理数据位数与<strong>CPU</strong>中的寄存器位数有关</p><h4 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h4><ul><li>主频</li><li>核数，每个核支持的线程数</li><li>吉普森法</li><li>CPI：执行一条指令所需时钟周期数</li><li>MIPS：每秒执行百万条指令</li><li>FLOPS：每秒浮点运算次数</li></ul><h4 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h4><p>存放二进制信息的总位数</p><h5 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h5><ul><li>存储单元个数×存储字长</li><li>字节数</li></ul><h5 id="辅存容量"><a href="#辅存容量" class="headerlink" title="辅存容量"></a>辅存容量</h5><p>字节数</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>总线是连接各个部件的信息传输线，是各个部件共享的的传输介质</p><h4 id="信息的传送"><a href="#信息的传送" class="headerlink" title="信息的传送"></a>信息的传送</h4><p>串行：传输数据一位一位传输，传输距离比较长</p><p>并行：传输数据多位传输，需要多根总线，传输距离比较短</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>以存储器为中心的双总线结构框图</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301339464.png" alt="image-20230530133908385"></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h5><p>芯片内部的总线</p><h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>计算机各部件之间的信息传输线</p><ul><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，与存储地址、I&#x2F;O地址有关</li><li>控制总线：有出 有入</li></ul><p>有出：存储器读，存储器写，总线允许、中断确认</p><p>有入：中断请求、总线请求</p><h5 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h5><p>用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信）之间的通信</p><p>按传输方式分为两类</p><ul><li>串行通信总线</li><li>并行通信总线</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>机械特性：尺寸、形状、管脚数及排列顺序</p><p>电气特性：传输方向和有效的电平范围</p><p>功能特性：每根传输线的功能</p><ul><li>地址</li><li>数据</li><li>控制</li></ul><p>时间特性：信号的时序关系</p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ol><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步&#x2F;异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线和控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标:负载能力</li></ol><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301356355.png" alt="image-20230530135654251"></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><h5 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h5><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301400732.png" alt="image-20230530140038637"></p><h5 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h5><p>双总线结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301401336.png" alt="image-20230530140137230"></p><p>三总线结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301403921.png" alt="image-20230530140308828"></p><p>另一种三总线结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301404412.png" alt="image-20230530140427320"></p><p>四总线结构</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301406060.png" alt="image-20230530140626965"></p><h4 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h4><h5 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p>主设备（模块）对总线有控制权</p><p>从设备（模块）响应从主设备发来的总线命令</p><h6 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h6><ul><li>集中式</li><li>分布式</li></ul><h5 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h5><ul><li>链式查询</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301415758.png" alt="image-20230530141517661"></p><p>缺点：优先级事先确定，与位置有关，对电路故障敏感</p><p>优点：结构简单，增加设备很容易，优先级算法简单，可靠性设计容易实现，速度慢</p><p>应用：微型计算机、嵌入式系统</p><ul><li>计数器定时查询</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301418371.png" alt="image-20230530141834281"></p><p>优点：优先级确定灵活</p><p>缺点：速度较慢</p><ul><li>独立请求方式</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301423882.png" alt="image-20230530142337784"></p><h5 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h5><h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h6><p>解决通信双方协调配合问题</p><h6 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h6><ul><li>申请分配阶段：主模块申请，总线仲裁决定</li><li>寻址阶段：主模块向从模块给出地址和命令</li><li>传数阶段：主模块和从模块交换数据</li><li>结束阶段：主从模块撤销有关信息</li></ul><h4 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h4><ul><li>同步通信：由统一时标控制数据传送，应用于总线长度比较短，各个模块存取时间比较一致</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301529660.png" alt="image-20230530152933567"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301530248.png" alt="image-20230530153004164"></p><ul><li>异步通信：采用应答方式，没有公共时钟标准</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301534669.png" alt="image-20230530153408573"></p><ul><li>半同步通信：同步、异步结合</li></ul><p>同步：发送方用系统时钟前沿发信号、接收方用系统时钟后沿判断、识别</p><p>异步：允许不同速度的模块和谐工作，增加一条“等待”响应信号wait</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301543480.png" alt="image-20230530154328379"></p><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>一个总线传输周期（以输入数据为例）</p><p>主模块发地址、命令 占用总线</p><p>从模块准备数据 不占用总线 总线空闲</p><p>从模块向主模块发数据 占用总线</p><ul><li>分离式通信：充分挖掘系统总线每个瞬间的潜力</li></ul><p>一个总线周期</p><ul><li>子周期1：主模块申请占用总线，使用完后即放弃总线的使用权</li><li>子周期2：从模块申请占用总线，将各种信息送至总线上</li></ul><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202305301554087.png" alt="image-20230530155439004"></p>]]></content>
      
      
      <categories>
          
          <category> 计组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器</title>
      <link href="/2023/04/20/2023-4-20-%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2023/04/20/2023-4-20-%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器的学习"><a href="#编辑器的学习" class="headerlink" title="编辑器的学习"></a>编辑器的学习</h2><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><h4 id="设置自动保存"><a href="#设置自动保存" class="headerlink" title="设置自动保存"></a>设置自动保存</h4><p>1.打开vscode编辑器，点击左下角设置图标（齿轮形状），点击settings</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304202154534.png" alt="image-20230420215411474"></p><p>2.在用户设置窗口中搜索”auto save”，将“Files: Auto Save”设置为“afterDelay”，那么可以指定等待时间。例如，如果将“afterDelay”设置为5000，则表示编辑器将等待5秒钟后自动保存未保存的更改。</p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304202155440.png" alt="image-20230420215546371"></p>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
          <category> vscode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编辑器</title>
      <link href="/2023/04/20/2023-5-29-%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2023/04/20/2023-5-29-%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器的学习"><a href="#编辑器的学习" class="headerlink" title="编辑器的学习"></a>编辑器的学习</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li>本页查找：Ctrl+F</li><li>查找和替换：Ctrl+R</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
          <category> idea </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM的学习</title>
      <link href="/2023/04/20/2023-4-20-SSM/"/>
      <url>/2023/04/20/2023-4-20-SSM/</url>
      
        <content type="html"><![CDATA[<h2 id="SSM的学习"><a href="#SSM的学习" class="headerlink" title="SSM的学习"></a>SSM的学习</h2><h3 id="spingboot整合ssm"><a href="#spingboot整合ssm" class="headerlink" title="spingboot整合ssm"></a>spingboot整合ssm</h3><h4 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/image-20230420202721323.png"></p><h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>错误通常出现在 Maven 项目中，表示 Maven 在解析依赖关系时无法找到 <code>org.springframework:spring-tx:5.3.7</code> 这个库的版本</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1.检查你的 Maven 配置文件 pom.xml 中是否有正确的库依赖声明，并且版本号是否正确。</p><p>比如我的项目对应的boot版本类型是2.4.5，Mybatis版本类型是2.2.0</p><p>2.确保你的 Internet 连接正常，并且可以访问 Maven 的仓库</p><h3 id="编写测试方法对查询功能进行测试"><a href="#编写测试方法对查询功能进行测试" class="headerlink" title="编写测试方法对查询功能进行测试"></a>编写测试方法对查询功能进行测试</h3><h4 id="遇到问题-1"><a href="#遇到问题-1" class="headerlink" title="遇到问题"></a>遇到问题</h4><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304212256706.png" alt="image-20230421225606540"></p><p><img src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304212257630.png" alt="image-20230421225720541"></p><h4 id="分析问题-1"><a href="#分析问题-1" class="headerlink" title="分析问题"></a>分析问题</h4><p>关于Spring MVC配置的异常。提示信息中提到了”No ServletContext set”，表明在执行WebMvcConfigurationSupport类中的resourceHandlerMapping方法时，无法获取到ServletContext对象，从而导致了异常</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>注释掉@EnableWebMvc ，具体原因未知，有待探索</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2023/04/10/2023-4-13-Hexo/"/>
      <url>/2023/04/10/2023-4-13-Hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023/04/10/2023-4-13-C/"/>
      <url>/2023/04/10/2023-4-13-C/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章"><a href="#这是我的第三篇文章" class="headerlink" title="这是我的第三篇文章"></a>这是我的第三篇文章</h2><p>你的sql语句打印出来看长啥样了吗没有，但是我测试过了没问题，问题就是我不知道怎么去出结果集里面的数据，那个循环会取出数据库里面所有的数据，你测试过程给我看，这样测试的？我打印出来了测试用单元测试，你这样测试多慢？哼，找到就行了呗，习惯，现在用junit。你写单元测试，这和单元测试有什么关系，养成习惯，规范一点，能不能先解决问题，来不及了，来得及，你不是为了完成作业，哼</p><p>你测试dao看service干啥，我看看咋了</p><p>你看，他老是给我打出所有，而且还把我id给改了，你这样看得舒服吗嗯，一串信息放在一起，你</p><p>胃痛，今晚就不应该吃那个冰淇淋，是你早上吃的太少了，我吃了两个为啥我不疼，好痛下次让你更疼</p><p>为啥有的有# 有的没有，不知道看你哪些写错了</p><p>你有没有想过为啥你的sql是灰色的，不知道移上去看看，IDEA功能很强大</p><p>我知道这个，但是我不知道咋用</p><p>好了，现在错误更多了，快睡觉吧一招回到解放前，我本来不报错了，哈哈哈</p><p>ctrl+f 搜索</p><p>junit测试：</p><ol><li>选择要测试的将光标移上去，然后按Alt+enter打开选项，选择要测试的方法，可以全选，</li><li>要测试哪个方法，先看看这个方法里面有哪些参数，然后创建对象比如GoodDaoImpl对象，调用这个方法，把参数传进去进行测试</li><li>一个一个set太麻烦了，可以使用插件：getAllsetter，使用方法：光标放到对象上面，然后按alt+enter，generate all setter with no </li><li>得到结果，不要直接使用sout输出，先List&lt;T&gt; goods &#x3D;…然后再 print一条一条显示goodsList.forEach(System.out::println);</li></ol><p>断点调试</p><ol><li>在你想要程序一步一步走的地方打上断点，</li><li>然后用调试方式运行测试</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/04/10/2023-4-13-Java/"/>
      <url>/2023/04/10/2023-4-13-Java/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四篇文章</title>
      <link href="/2023/04/10/2023-4-13-Python/"/>
      <url>/2023/04/10/2023-4-13-Python/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第四篇文章"><a href="#这是我的第四篇文章" class="headerlink" title="这是我的第四篇文章"></a>这是我的第四篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date; function createtime() { now.setTime(now.getTime() + 1e3); var e = new Date("04/010/2023 00:00:00"), t = Math.trunc(234e8 + (now - e) / 1e3 * 17), a = (t / 1496e5).toFixed(6), o = new Date("04/12/2023 00:00:00"), n = (now - o) / 1e3 / 60 / 60 / 24, r = Math.floor(n), i = (now - o) / 1e3 / 60 / 60 - 24 * r, s = Math.floor(i); 1 == String(s).length && (s = "0" + s); var d = (now - o) / 1e3 / 60 - 1440 * r - 60 * s, l = Math.floor(d); 1 == String(l).length && (l = "0" + l); var g = (now - o) / 1e3 - 86400 * r - 3600 * s - 60 * l, b = Math.round(g); 1 == String(b).length && (b = "0" + b); let c = ""; c = s < 18 && s >= 9 ? `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-科研摸鱼中.svg' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>` : `<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = c) } setInterval((() => { createtime() }), 1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var n, e, i, h, t = .05, s = document.getElementById("universe"), o = !0, a = "180,184,240", r = "226,225,142", d = "226,225,224", c = []; function f() { n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute("width", n), s.setAttribute("height", e) } function u() { h.clearRect(0, 0, n, e); for (var t = c.length, i = 0; i < t; i++) { var s = c[i]; s.move(), s.fadeIn(), s.fadeOut(), s.draw() } } function y() { this.reset = function () { this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1) }, this.fadeIn = function () { this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do) }, this.fadeOut = function () { this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do / 2, (this.x > n || this.y < 0) && (this.fadingOut = !1, this.reset())) }, this.draw = function () { if (h.beginPath(), this.giant) h.fillStyle = "rgba(" + a + "," + this.opacity + ")", h.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1); else if (this.comet) { h.fillStyle = "rgba(" + d + "," + this.opacity + ")", h.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1); for (var t = 0; t < 30; t++)h.fillStyle = "rgba(" + d + "," + (this.opacity - this.opacity / 20 * t) + ")", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill() } else h.fillStyle = "rgba(" + r + "," + this.opacity + ")", h.rect(this.x, this.y, this.r, this.r); h.closePath(), h.fill() }, this.move = function () { this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0) }, setTimeout(function () { o = !1 }, 50) } function m(t) { return Math.floor(1e3 * Math.random()) + 1 < 10 * t } function l(t, i) { return Math.random() * (i - t) + t } f(), window.addEventListener("resize", f, !1), function () { h = s.getContext("2d"); for (var t = 0; t < i; t++)c[t] = new y, c[t].reset(); u() }(), function t() { document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t) }() };dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {    background: #3ecdf1;    color: #f2f2f2;}@font-face {    /* 为载入的字体取名字(随意) */    font-family: 'YSHST';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(/font/霞鹜文楷.woff2);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {    left: -38px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {    animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/*菜单图标大小*/svg.menu_icon {    width: 1.28em;    height: 1.28em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}/*社交图标大小*/svg.social_icon {    width: 1.20em;    height: 1.20em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
