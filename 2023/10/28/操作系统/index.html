<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>pigWzq | pigWzq</title><meta name="author" content="Wzq"><meta name="copyright" content="Wzq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="123456789title: 操作系统description: 操作系统date: 2023-10-28 11:45:00update: 2023-10-28 11:45:00tags:  - 课程categories:  - 操作系统swiper_index: 16  操作系统进程的描述与控制程序顺序执行程序执行过程中通常存在顺序执行问题  构成程序的若干个程序段之间 组成程序段的多条语句之间">
<meta property="og:type" content="article">
<meta property="og:title" content="pigWzq">
<meta property="og:url" content="http://pigwzq.github.io/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="pigWzq">
<meta property="og:description" content="123456789title: 操作系统description: 操作系统date: 2023-10-28 11:45:00update: 2023-10-28 11:45:00tags:  - 课程categories:  - 操作系统swiper_index: 16  操作系统进程的描述与控制程序顺序执行程序执行过程中通常存在顺序执行问题  构成程序的若干个程序段之间 组成程序段的多条语句之间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_4.webp">
<meta property="article:published_time" content="2023-10-27T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-26T03:01:11.935Z">
<meta property="article:author" content="Wzq">
<meta property="article:tag" content="演示">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_4.webp"><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="http://pigwzq.github.io/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pigWzq',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-26 11:01:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304202108861.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-kunnanjinguidang"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-kunnanjinguidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-doorknob"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-doorknob"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiebaogao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingpiao-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-mianxingxinxingzuanshishuijing"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingxinxingzuanshishuijing"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_4.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="pigWzq"><span class="site-name">pigWzq</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-kunnanjinguidang"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-kunnanjinguidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-doorknob"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-doorknob"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiebaogao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingpiao-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-mianxingxinxingzuanshishuijing"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingxinxingzuanshishuijing"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-27T16:00:00.000Z" title="发表于 2023-10-28 00:00:00">2023-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-26T03:01:11.935Z" title="更新于 2023-11-26 11:01:11">2023-11-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: 操作系统</span><br><span class="line">description: 操作系统</span><br><span class="line">date: 2023-10-28 11:45:00</span><br><span class="line">update: 2023-10-28 11:45:00</span><br><span class="line">tags:</span><br><span class="line">  - 课程</span><br><span class="line">categories:</span><br><span class="line">  - 操作系统</span><br><span class="line">swiper_index: 16</span><br></pre></td></tr></table></figure>

<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h3><p>程序执行过程中通常存在顺序执行问题</p>
<ul>
<li>构成程序的若干个程序段之间</li>
<li>组成程序段的多条语句之间</li>
</ul>
<h4 id="程序顺序执行时的特征"><a href="#程序顺序执行时的特征" class="headerlink" title="程序顺序执行时的特征"></a>程序顺序执行时的特征</h4><ol>
<li><p>顺序性</p>
<p>处理机的操作，严格按照规定顺序执行</p>
</li>
<li><p>封闭性</p>
<ul>
<li>封闭环境下运行，程序独占全机资源</li>
<li>只有当前运行程序才能改变资源状态</li>
<li>程序执行结果不受外界因素的影响</li>
</ul>
</li>
<li><p>可再现性</p>
<p>只要程序执行时的环境和初始条件相同，程序重复执行结果相同</p>
</li>
</ol>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>在一段时间里，多道程序一起共享计算机系统的资源，一起操作向前推进</p>
<h4 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h4><ol>
<li><p>间断性</p>
<p>”执行一暂停执行—执行”的活动规律</p>
</li>
<li><p>失去封闭性</p>
<p>系统资源共享及资源状态改变的多样性，致使程序运行失去封闭性，程序运行必然会受到其它程序的影响</p>
</li>
<li><p>不可再现性</p>
<p>并发执行的程序，计算结果与其执行速度及时间有关</p>
</li>
</ol>
<h3 id="进程的定义及特征"><a href="#进程的定义及特征" class="headerlink" title="进程的定义及特征"></a>进程的定义及特征</h3><h4 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h4><ul>
<li>并发、共享及多道程序环境</li>
<li>基于程序的概念已不能完整、有效地描述并发程序在内存中的运行状态</li>
<li>必须建立并发程序的新的描述和控制机制</li>
<li>基于程序段、数据段和进程控制块而引入进程的概念以对应程序的运行过程</li>
<li>进程控制块存放了进程标识符、进程运行的当前状态、程序和数据的地址以及关于该程序运行时的CPU环境信息</li>
</ul>
<h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol>
<li>进程是可并发执行的程序在一个数据集合上的运行过程，亦即进程实体的运行过程<br><strong>进程实体由程序段、数据段及进程控制块三部分构成</strong></li>
<li>进程是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h4 id="进程的特征—-与程序的区别与联系"><a href="#进程的特征—-与程序的区别与联系" class="headerlink" title="进程的特征—-与程序的区别与联系"></a>进程的特征—-与程序的区别与联系</h4><ol>
<li><p>结构特征</p>
<p>程序段、数据段及进程控制块</p>
</li>
<li><p>动态性</p>
<p>生命周期及“执行”本质</p>
</li>
<li><p>并发性</p>
<p>共存于内存、宏观同时运行</p>
</li>
<li><p>独立性</p>
<p>调度、资源分配、运行</p>
</li>
<li><p>异步性</p>
<p>推进相互独立、速度不可预知</p>
</li>
</ol>
<h3 id="进程并发制约关系及临界区"><a href="#进程并发制约关系及临界区" class="headerlink" title="进程并发制约关系及临界区"></a>进程并发制约关系及临界区</h3><h4 id="并发进程间制约关系"><a href="#并发进程间制约关系" class="headerlink" title="并发进程间制约关系"></a>并发进程间制约关系</h4><p>资源共享关系—-间接制约</p>
<ul>
<li>多个进程彼此无关，完全不知道或只能间接感知其它进程的存在</li>
<li>系统须保证诸进程能互斥地访问临界资源</li>
<li>系统资源应统一分配，而不允许用户进程直接用</li>
</ul>
<p>相互合作关系—-直接制约<br>系统应保证相互合作的诸进程在执行次序上的协调和防止与时间有关的差错</p>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>一段时间内只允许一个进程访问的资源。如 许多物理设备、变量及表格</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>每个进程中访问临界资源的那段代码称为临界区<br>保证诸进程互斥地进入自己的临界区是实现它们对临界资源的互斥访问的充要条件（同一个临界资源）</p>
<h3 id="进程同步机制基本准则"><a href="#进程同步机制基本准则" class="headerlink" title="进程同步机制基本准则"></a>进程同步机制基本准则</h3><ol>
<li><p>空闲让进</p>
<p>当无进程处于临界区时，可允许一个请求进入临界区的进程立即进入自己的临界区</p>
</li>
<li><p>忙则等待</p>
<p>当已有进程进入自己的临界区时，所有企图进入临界区的进程必须等待</p>
</li>
<li><p>有限等待</p>
<p>对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区</p>
</li>
<li><p>让权等待</p>
<p>当进程不能进入自己的临界区时，应释放处理机</p>
</li>
</ol>
<h3 id="进程互斥访问临界资源的软件解决方案"><a href="#进程互斥访问临界资源的软件解决方案" class="headerlink" title="进程互斥访问临界资源的软件解决方案"></a>进程互斥访问临界资源的软件解决方案</h3><h4 id="进程互斥算法1-设置访问编号"><a href="#进程互斥算法1-设置访问编号" class="headerlink" title="进程互斥算法1-设置访问编号"></a>进程互斥算法1-设置访问编号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var turn：integer：=i；[全局变量]</span><br><span class="line"></span><br><span class="line">Pi：while turn!=i</span><br><span class="line"></span><br><span class="line">		do no_op;</span><br><span class="line"></span><br><span class="line">		临界区</span><br><span class="line"></span><br><span class="line">		turn:=j;</span><br></pre></td></tr></table></figure>

<p>强制设置进程访问，违背了空闲让进</p>
<p>进不了临界区也没有让出处理器资源，违背了让权等待</p>
<h4 id="进程互斥算法2-设置访问标志"><a href="#进程互斥算法2-设置访问标志" class="headerlink" title="进程互斥算法2-设置访问标志"></a>进程互斥算法2-设置访问标志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量]</span><br><span class="line"></span><br><span class="line">Pi：while flagj</span><br><span class="line"></span><br><span class="line">		do no_op;</span><br><span class="line"></span><br><span class="line">		flagi:=true;</span><br><span class="line"></span><br><span class="line">		临界区</span><br><span class="line"></span><br><span class="line">		flagi:=false;</span><br></pre></td></tr></table></figure>

<p>违背了忙则等待和让权等待</p>
<h4 id="进程互斥算法3-设置欲访问标志"><a href="#进程互斥算法3-设置欲访问标志" class="headerlink" title="进程互斥算法3-设置欲访问标志"></a>进程互斥算法3-设置欲访问标志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量] </span><br><span class="line"></span><br><span class="line">Pi：flagi:=true;</span><br><span class="line"></span><br><span class="line">		while flagj</span><br><span class="line"></span><br><span class="line">		do no_op;</span><br><span class="line"></span><br><span class="line">		临界区</span><br><span class="line"></span><br><span class="line">		flagi:=false;</span><br></pre></td></tr></table></figure>

<p>违背了空闲让进、有限等待和让权等待</p>
<h4 id="进程互斥算法4-编号-标志（Peterson算法）"><a href="#进程互斥算法4-编号-标志（Peterson算法）" class="headerlink" title="进程互斥算法4-编号+标志（Peterson算法）"></a>进程互斥算法4-编号+标志（Peterson算法）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Var flagi,flagj:boolean:=false,false;[全局变量] </span><br><span class="line"></span><br><span class="line">	turn：integer；</span><br><span class="line"></span><br><span class="line">Pi：flagi：=true；trun:=j;</span><br><span class="line"></span><br><span class="line">		while(flagj and turn==j)</span><br><span class="line"></span><br><span class="line">		do no_op;</span><br><span class="line"></span><br><span class="line">		临界区</span><br><span class="line"></span><br><span class="line">		flagi:=false;</span><br></pre></td></tr></table></figure>

<p>违背了让权等待</p>
<h3 id="整型信号量机制"><a href="#整型信号量机制" class="headerlink" title="整型信号量机制"></a>整型信号量机制</h3><p>整型信号量s（计算机资源可用的数量）除初始化外，仅能被两个标准的原子操作wait(s)和signal(s)亦即P&#x2F;V操作来访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(s)：while s&lt;=0 do no_op;</span><br><span class="line">			    s:=s-1;</span><br><span class="line">signal(s):s:=s+1;</span><br></pre></td></tr></table></figure>

<p>违背了让权等待</p>
<h3 id="记录型信号量机制"><a href="#记录型信号量机制" class="headerlink" title="记录型信号量机制"></a>记录型信号量机制</h3><h4 id="信号量类型声明"><a href="#信号量类型声明" class="headerlink" title="信号量类型声明"></a>信号量类型声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type semphore=record//信号量</span><br><span class="line">	value:integer;//&gt;=0表示对该信号量的可用资源数量，&lt;=0其绝对值表示阻塞队列的长度，即有多少个进程正在等待资源</span><br><span class="line">	L:list of process;//当前等待使用资源的进程列表或者队列</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="wait（s）操作描述"><a href="#wait（s）操作描述" class="headerlink" title="wait（s）操作描述"></a>wait（s）操作描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure wait(s)</span><br><span class="line">Var s:semphore;</span><br><span class="line">begin</span><br><span class="line">	s.value:=s.value -1;</span><br><span class="line">	if s.value&lt;0 then block(s.L);//&lt;0表示已经没有资源了，无资源则将该进程挂到阻塞队列</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="signal（s）操作描述"><a href="#signal（s）操作描述" class="headerlink" title="signal（s）操作描述"></a>signal（s）操作描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure signal(s)</span><br><span class="line">Var s:semphore;</span><br><span class="line">begin</span><br><span class="line">	s.value:=s.value 1;</span><br><span class="line">	if s.value&lt;=0 then wakeup(s.L);//=0表示阻塞队列长度为|-1|，则需要唤醒被阻塞进程</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="AND型信号量集机制"><a href="#AND型信号量集机制" class="headerlink" title="AND型信号量集机制"></a>AND型信号量集机制</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>对于多个进程要共享两个以上的资源的情况，记录型信号量机制侧可能由于使用不当而导致死锁的发生</p>
<p><strong>对于临界资源的互斥信号量的初始值为1</strong></p>
<h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><p>若干个临界资源的分配采取原子操作方式</p>
<h4 id="Swait（s1，s2，…，sn）操作"><a href="#Swait（s1，s2，…，sn）操作" class="headerlink" title="Swait（s1，s2，…，sn）操作"></a>Swait（s1，s2，…，sn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure Swait(s1,s2,...sn)</span><br><span class="line">Var s1,s2,...,sn:semphore;</span><br><span class="line">begin</span><br><span class="line">	if s1.value≥1 and..and s.value≥1</span><br><span class="line">	then for i:=1 to n do</span><br><span class="line">		si.value:=s .value -1;</span><br><span class="line">	else blockProcessAndResetPC(sfirstless);//挂到第一个不能满足的信号量阻塞队列上，资源重新做申请操作</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Swait详细"><a href="#Swait详细" class="headerlink" title="Swait详细"></a>Swait详细</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">    Var zSbG:boolean:=false;</span><br><span class="line">    for i:=1 to n do</span><br><span class="line">    &#123;if (si.value &lt;1)</span><br><span class="line">    	&#123;zSbG:=true;break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zSbG)</span><br><span class="line">    &#123;ResetPC();</span><br><span class="line">    block(si.L);&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;for i:=1 to n do</span><br><span class="line">    si.value:=si.value -1;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Ssignal（s1，s2，…，sn）操作"><a href="#Ssignal（s1，s2，…，sn）操作" class="headerlink" title="Ssignal（s1，s2，…，sn）操作"></a>Ssignal（s1，s2，…，sn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure Ssignal(s1,s2,...,sn)</span><br><span class="line">Var s1,s2,...,sn semphore;</span><br><span class="line">begin</span><br><span class="line">	for i:=1 to n do</span><br><span class="line">		si.value:=si.value＋1;</span><br><span class="line">		wakeup(si.L);</span><br><span class="line">	endfor;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="一般信号量集机制"><a href="#一般信号量集机制" class="headerlink" title="一般信号量集机制"></a>一般信号量集机制</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><ul>
<li>记录型信号量及AND信号量集机制中，wait(s)和signal(s)操作仅能对信号量施以增1和减1的操作，即每次只能获得或释放一个单位的临界资源。当一次需d个某类临界资源时，便需要进行d次wait(s)操作，这显然是低效的。</li>
<li>此外，在有些情况下，要求当资源数量低于某一下限值时，便不予分配。故在每次分配之前，都必须测试该资源的数量是否不小于测试值t。</li>
<li>基于以上两点可以对AND信号量集机制进行扩充，形成一般化的“信号量集”机制。</li>
</ul>
<h4 id="Swait（s1，t1，d1，…，sn，tn，dn）操作"><a href="#Swait（s1，t1，d1，…，sn，tn，dn）操作" class="headerlink" title="Swait（s1，t1，d1，…，sn，tn，dn）操作"></a>Swait（s1，t1，d1，…，sn，tn，dn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure Swait(s1,t1,d1,...,sn,tn,dn)</span><br><span class="line">Var s1,s2,...,sn:semphore;//信号量</span><br><span class="line">	t,t2,…,tnd,d2,…,dn:integer;//d为申请多少资源，t为下限值</span><br><span class="line">begin</span><br><span class="line">	ifs.value≥tand.…and sn.value≥tn</span><br><span class="line">	then for i:=1 to n do</span><br><span class="line">		si.value:=si.value -di;</span><br><span class="line">	else blockProcessAndResetPC(sfirstless);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Swait详细-1"><a href="#Swait详细-1" class="headerlink" title="Swait详细"></a>Swait详细</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">Var zSbG:boolean:=false;</span><br><span class="line">for i:=1 to n do</span><br><span class="line">&#123;if (si.value &lt;t</span><br><span class="line">	&#123;zSbG:=true;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (zSbG)</span><br><span class="line">&#123;ResetPC();</span><br><span class="line">block(si.L);&#125;</span><br><span class="line">else</span><br><span class="line">&#123;for i:=1 to n do</span><br><span class="line">	si.value:=si.value di;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Ssignal（s1，d1，…，sn，dn）操作"><a href="#Ssignal（s1，d1，…，sn，dn）操作" class="headerlink" title="Ssignal（s1，d1，…，sn，dn）操作"></a>Ssignal（s1，d1，…，sn，dn）操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure Ssignal(s1,d1,...sn,dn)</span><br><span class="line">Var s1,s2,...,s:semphore;</span><br><span class="line">	d1,d2,…,dn:integer;,</span><br><span class="line">begin</span><br><span class="line">	for i:=1 to n do</span><br><span class="line">		si.value:=si.value d;</span><br><span class="line">		wakeup(si.L);</span><br><span class="line">	endfor;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="一般信号量集的几种特殊情况"><a href="#一般信号量集的几种特殊情况" class="headerlink" title="一般信号量集的几种特殊情况"></a>一般信号量集的几种特殊情况</h4><h5 id="Swait-s-d-d"><a href="#Swait-s-d-d" class="headerlink" title="Swait(s,d,d)"></a>Swait(s,d,d)</h5><p>信号量集中只有一个信号量，但它允许每次申请d个资源；当现有资源少于d个时，便不予分配</p>
<h5 id="Swait-s-1-1"><a href="#Swait-s-1-1" class="headerlink" title="Swait(s,1,1)"></a>Swait(s,1,1)</h5><p>此时的信号量集已退化为一般的记录型信号量</p>
<h5 id="Swait-s-1-0"><a href="#Swait-s-1-0" class="headerlink" title="Swait(s,1,0)"></a>Swait(s,1,0)</h5><ul>
<li>一种特殊且很有用的信号量，相当于可控开关</li>
<li>当s≥1时，允许多个进程进入某特定区；当s变为0后，将阻止任何进程进入该特定区</li>
</ul>
<h3 id="基于信号量机制解决进程并发问题的应用基础"><a href="#基于信号量机制解决进程并发问题的应用基础" class="headerlink" title="基于信号量机制解决进程并发问题的应用基础"></a>基于信号量机制解决进程并发问题的应用基础</h3><h4 id="利用信号量实现互斥—-主程序"><a href="#利用信号量实现互斥—-主程序" class="headerlink" title="利用信号量实现互斥—-主程序"></a>利用信号量实现互斥—-主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Var mutex:semphore:=1;//互斥信号量，且初始值必须为1</span><br><span class="line">begin</span><br><span class="line">	parbegin//表示process1和process2可以并发执行</span><br><span class="line">		processl;</span><br><span class="line">		process2;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="利用信号量实现互斥—-子程序"><a href="#利用信号量实现互斥—-子程序" class="headerlink" title="利用信号量实现互斥—-子程序"></a>利用信号量实现互斥—-子程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process1:</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区</span><br><span class="line">		signal(mutex);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><ol>
<li><p>生产者一消费者问题是相互合作进程关系的一种抽象</p>
<ul>
<li>输入时的输入进程与计算进程</li>
<li>输出时的计算进程与输出进程</li>
</ul>
</li>
<li><p>生产者一消费者问题具有很大的代表性和实用价值</p>
<p>计算机系统一IPO系统</p>
</li>
</ol>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul>
<li>一群生产者进程在生产数据，并将此数据提供给一群消费者进程去消费处理</li>
<li>为使二者可以并发执行，在它们之间设置了一个具有n个缓冲区的循环缓冲，生产者进程可以将它所生产的数据放入一个缓冲区中，消费者进程可以从一个缓冲区中取得一个数据消费</li>
<li>异步运行方式及彼此必须保持同步</li>
</ul>
<h4 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h4><h5 id="空缓冲区和满缓冲区"><a href="#空缓冲区和满缓冲区" class="headerlink" title="空缓冲区和满缓冲区"></a>空缓冲区和满缓冲区</h5><ul>
<li>空缓冲区是指未投放数据或虽曾投放数据但对应数据已被取走的缓冲区</li>
<li>满缓冲区则指已投放数据且对应数据尚未被取走的缓冲区</li>
</ul>
<h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><ul>
<li>当生产者进程要把所生产的数据送入循环缓冲时，首先应检查是否有空缓冲区存在，若有，则可向对应空缓冲区中投放数据，同时通知逍费者进程；否则只有等待。</li>
<li>当消费者进程要从循环缓冲中提取数据时，首先应检查是否有满缓冲区存在，若有，则从对应满缓冲区中提取数据，并通知生产者进程，否则只有等待</li>
</ul>
<h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>缓冲区及其“指针”是临界资源：多个生产者&#x2F;消费者进程</p>
<h4 id="程序变量设计"><a href="#程序变量设计" class="headerlink" title="程序变量设计"></a>程序变量设计</h4><h5 id="循环缓冲表示机制"><a href="#循环缓冲表示机制" class="headerlink" title="循环缓冲表示机制"></a>循环缓冲表示机制</h5><p>一维数组ouffer::array[0.n-l]of item;</p>
<h5 id="输入指针in"><a href="#输入指针in" class="headerlink" title="输入指针in"></a>输入指针in</h5><ul>
<li>指示下一个可以投放数据的缓冲区</li>
<li>初始值为0；变化方式：in:&#x3D;(in+1) mod n</li>
</ul>
<h5 id="输出指针out"><a href="#输出指针out" class="headerlink" title="输出指针out"></a>输出指针out</h5><ul>
<li>指示下一个可以获取数据的缓冲区</li>
<li>初始值为0；变化方式：out:&#x3D;(out+1) mod n</li>
</ul>
<h5 id="暂存数据"><a href="#暂存数据" class="headerlink" title="暂存数据"></a>暂存数据</h5><p>nextp&#x2F;nextc暂存每次要生产或消费的数据</p>
<h4 id="程序信号量的设计"><a href="#程序信号量的设计" class="headerlink" title="程序信号量的设计"></a>程序信号量的设计</h4><h5 id="循环缓冲（缓冲区及其指针）的互斥使用"><a href="#循环缓冲（缓冲区及其指针）的互斥使用" class="headerlink" title="循环缓冲（缓冲区及其指针）的互斥使用"></a>循环缓冲（缓冲区及其指针）的互斥使用</h5><p>互斥信号量mutex,初始值为1</p>
<h5 id="资源信号量"><a href="#资源信号量" class="headerlink" title="资源信号量"></a>资源信号量</h5><ul>
<li>empty表示循环缓冲中的空缓冲区的数量其初始值为n</li>
<li>full表示循环缓冲中的满缓冲区的数量，其初始值为0</li>
</ul>
<h4 id="主程序设计"><a href="#主程序设计" class="headerlink" title="主程序设计"></a>主程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var buffer:array [0..n-1]of item;//循环缓冲</span><br><span class="line">	in,out:integer :0,0;//输入输出指针</span><br><span class="line">	mutex,empty,full semphore :=1,n,0</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		producer1;..produceri;...producerY;</span><br><span class="line">		consumer1;..consumerj;...;consumerX；</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="生产者子程序设计"><a href="#生产者子程序设计" class="headerlink" title="生产者子程序设计"></a>生产者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">produceri;:</span><br><span class="line">Var nextp:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			produce an item in nextp;</span><br><span class="line">			wait(empty);</span><br><span class="line">			wait(mutex);</span><br><span class="line">			buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">			signal(mutex);</span><br><span class="line">			signal(full);</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h4 id="消费者子程序设计"><a href="#消费者子程序设计" class="headerlink" title="消费者子程序设计"></a>消费者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(full);</span><br><span class="line">        	wait(mutex);</span><br><span class="line">			nextc:=buffer[out];out:=(out+1)mod n</span><br><span class="line">			signal(mutex);</span><br><span class="line">			signal(empty);</span><br><span class="line">			consume.the item in nextc;</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h4 id="初步解决方案的反思"><a href="#初步解决方案的反思" class="headerlink" title="初步解决方案的反思"></a>初步解决方案的反思</h4><h5 id="关于相邻wait（signal）操作颠倒的分析"><a href="#关于相邻wait（signal）操作颠倒的分析" class="headerlink" title="关于相邻wait（signal）操作颠倒的分析"></a>关于相邻wait（signal）操作颠倒的分析</h5><p>在生产者一消费者问题中，如果将两个wait操作即wait(full)和wait(nutex)互换位置；或者是将signal((mutex)与signal(full)互换位置，结果会如何？</p>
<ol>
<li><p>wait(full)和wait(mutex)互换位置</p>
<ul>
<li><p>消费者wait(mutex)&#x3D;&gt;wait(full)</p>
</li>
<li><p>生产者wait(empty)&#x3D;&gt;wait(mutex)</p>
</li>
<li><p>时间节点：循环缓冲均为空缓冲区时</p>
</li>
<li><p>陷入死锁</p>
</li>
</ul>
</li>
<li><p>signal(mutex)与signal(full)互换位置</p>
<p>没有影响</p>
</li>
</ol>
<h5 id="关于signal操作缺失的分析"><a href="#关于signal操作缺失的分析" class="headerlink" title="关于signal操作缺失的分析"></a>关于signal操作缺失的分析</h5><p>在生产者一消费者问题中，如果缺少了signal(full)或signal(empty),对执行结果会有何影响？</p>
<ol>
<li>缺少了signal（full）<ul>
<li>生产者：开始—&gt;生产者生产数据填满n个缓冲区时—-&gt;陷入死锁</li>
<li>消费者：等待full信号量—-&gt;陷入死锁</li>
</ul>
</li>
<li>缺少了signal（empty）<ul>
<li>生产者：等待empty信号量—-&gt;陷入死锁</li>
<li>消费者：开始—-&gt;消费者取走了n个缓冲区数据时—-&gt;陷入死锁</li>
</ul>
</li>
</ol>
<h4 id="基于AND信号量的生产-x2F-消费者子程序设计"><a href="#基于AND信号量的生产-x2F-消费者子程序设计" class="headerlink" title="基于AND信号量的生产&#x2F;消费者子程序设计"></a>基于AND信号量的生产&#x2F;消费者子程序设计</h4><h5 id="生产者子程序"><a href="#生产者子程序" class="headerlink" title="生产者子程序"></a>生产者子程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">produceri;:</span><br><span class="line">Var nextp:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			produce an item in nextp;</span><br><span class="line">			Swait(empty,mutex);</span><br><span class="line">			buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">			Ssignal(mutex,full);</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h5 id="消费者子程序"><a href="#消费者子程序" class="headerlink" title="消费者子程序"></a>消费者子程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			Swait(full,mutex);</span><br><span class="line">			nextc:=buffer[out];out:=(out+1)mod n</span><br><span class="line">			Ssignal(mutex,empty);</span><br><span class="line">			consume.the item in nextc;</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h4 id="同步问题程序设计要领"><a href="#同步问题程序设计要领" class="headerlink" title="同步问题程序设计要领"></a>同步问题程序设计要领</h4><ul>
<li>每个并发子程序关于互斥信号量的wait与signal操作必须在同一子程序中成对出现</li>
<li>关于资源信号量的wait与signal操作同样需成对出现，但可以分别处于不同的并发子程序中</li>
<li>每个并发子程序中的多个wait操作的顺序不能颠倒，即资源信号量wait操作执行在前而互斥信号量wait操作执行在后，否则可能引起死锁</li>
<li>每个并发子程序中的多个signal操作的执行顺序无关紧要</li>
<li>非临界资源访问操作无需放到临界区中，且最好放到临界区外</li>
</ul>
<h4 id="ZGS版"><a href="#ZGS版" class="headerlink" title="ZGS版"></a>ZGS版</h4><h5 id="主程序设计-1"><a href="#主程序设计-1" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var buffer:array [0..n-1]of item;</span><br><span class="line">	in,out:integer :=0,0;</span><br><span class="line">	mutexP,mutexC,empty,full semphore :=1,1,n,0；</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		producer;..produceri;...producery;</span><br><span class="line">		consumer;...consumerj;...;consumerx;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="生产者子程序设计ZGS版"><a href="#生产者子程序设计ZGS版" class="headerlink" title="生产者子程序设计ZGS版"></a>生产者子程序设计ZGS版</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">produceri:</span><br><span class="line">Var nextp:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			produce an item in nextp;</span><br><span class="line">			wait(empty);</span><br><span class="line">			wait(mutexP);</span><br><span class="line">			buffer[in]:=nextp;in :=(in+1)mod n;</span><br><span class="line">			signal(mutexP);</span><br><span class="line">			signal(full);</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h5 id="消费者子程序设计ZGS版"><a href="#消费者子程序设计ZGS版" class="headerlink" title="消费者子程序设计ZGS版"></a>消费者子程序设计ZGS版</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">consumerj:</span><br><span class="line">Var nextc:item;</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(full);</span><br><span class="line">			wait(mutexC);</span><br><span class="line">			nextc:=buffer[out];out :=(out+1) mod n;</span><br><span class="line">			signal(mutexC);</span><br><span class="line">			signal(empty);</span><br><span class="line">			consume the item in nextc;</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>哲学家进餐问题是典型的同步问题</p>
<ul>
<li>五个哲学家共用一张圆桌，分别坐在环桌均匀摆放的五张椅子上，并全部实践着交替地进行思考和进餐的生活方式</li>
<li>圆桌上放有五支筷子，均匀排放在哲学家之间的位置上</li>
<li>哲学家饥饿时便试图去取用圆桌上最靠近他左右两端的两支筷子，且只有在同时拿到两支筷子时方可进餐，进餐完毕则把筷子放回原处，并继续进行思考</li>
</ul>
<h4 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h4><ol>
<li><p>筷子是临界资源<br>信号量数组chopstick[0..4],初始值均为1</p>
</li>
<li><p>第i个哲学家活动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Think;</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+1)mod 5])</span><br><span class="line">Eat;</span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+1)mod 5]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述解决方案在五个哲学家同时饥饿且各自拿起左边筷子的情况下会引起死锁</p>
</li>
<li><p>避免死锁的三种方法</p>
<ul>
<li>仅当哲学家左右两支筷子均可使用时，才允许他拿筷进餐</li>
<li>奇数号哲学家先拿左筷后拿右筷；而偶数号哲学家则相反</li>
<li>至多允许四个哲学家同时进餐，以保证至少有一个哲学家可以同时拿到两支筷子而进餐</li>
</ul>
</li>
</ol>
<h4 id="双筷齐举-AND型信号量"><a href="#双筷齐举-AND型信号量" class="headerlink" title="双筷齐举[AND型信号量]"></a>双筷齐举[AND型信号量]</h4><h5 id="主程序设计-2"><a href="#主程序设计-2" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		philosophy0;</span><br><span class="line">		…;philosophyi;…</span><br><span class="line">		philosophya;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="子程序设计"><a href="#子程序设计" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		Think;</span><br><span class="line">		Swait(chopstick[i],chopstick[(i+1)mod 5]);</span><br><span class="line">		Eat;</span><br><span class="line">		Ssignal(chopstick[i],chopstick[(i+1)mod 5]);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="双筷齐举-记录型信号量"><a href="#双筷齐举-记录型信号量" class="headerlink" title="双筷齐举[记录型信号量]"></a>双筷齐举[记录型信号量]</h4><h5 id="主程序设计-3"><a href="#主程序设计-3" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">mutex:semphore:=1;</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		philosophy0;</span><br><span class="line">		…;philosophyi;…</span><br><span class="line">		philosophya;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="子程序设计-1"><a href="#子程序设计-1" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		Think;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+1)mod 5]);</span><br><span class="line">		signal(mutex);</span><br><span class="line">		Eat;</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+1)mod 5]);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="奇偶有别-记录型信号量"><a href="#奇偶有别-记录型信号量" class="headerlink" title="奇偶有别[记录型信号量]"></a>奇偶有别[记录型信号量]</h4><h5 id="主程序设计-4"><a href="#主程序设计-4" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1)</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		philosophy0;</span><br><span class="line">		…;philosophyi;…</span><br><span class="line">		philosophya;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="子程序设计-奇数"><a href="#子程序设计-奇数" class="headerlink" title="子程序设计[奇数]"></a>子程序设计[奇数]</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">philosophyi（i为奇数，即奇数号哲学家）：</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		Think;</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+1)mod 5]);</span><br><span class="line">		Eat;</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+1)mod 5]);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="子程序设计-偶数"><a href="#子程序设计-偶数" class="headerlink" title="子程序设计[偶数]"></a>子程序设计[偶数]</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">philosophyi（i为偶数，即偶数号哲学家）：</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		Think;</span><br><span class="line">		wait(chopstick[(i+1)mod 5]);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		Eat;</span><br><span class="line">		signal(chopstick[(i+1)mod 5]);</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="进餐限数-记录型信号量"><a href="#进餐限数-记录型信号量" class="headerlink" title="进餐限数[记录型信号量]"></a>进餐限数[记录型信号量]</h4><h5 id="主程序设计-5"><a href="#主程序设计-5" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Var</span><br><span class="line">chopstick:array[0..4]of semphore:=(1,1,1,1,1);</span><br><span class="line">limit:semphore:=4;</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		philosophy0;</span><br><span class="line">		…;philosophyi;…</span><br><span class="line">		philosophya;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="子程序设计-2"><a href="#子程序设计-2" class="headerlink" title="子程序设计"></a>子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">philosophyi:</span><br><span class="line">begin</span><br><span class="line">	repeat</span><br><span class="line">		Think;</span><br><span class="line">		wait(limit);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+1)mod 5]);</span><br><span class="line">		signal(limit);</span><br><span class="line">		Eat;</span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+1)mod 5]);</span><br><span class="line">	until false;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><ol>
<li>读者一写者问题是指保证任何写者进程必须与其它进程互斥地访问共享数据对象（数据文件或记录)的同步问题。<ul>
<li>存在多个进程共享一个数据对象</li>
<li>只要求读的进程称为读者进程</li>
<li>拥有写或修改要求的进程称为写者进程</li>
<li>允许多个读者进程同时执行读操作</li>
<li>任何写者进程的执行具有排它性</li>
</ul>
</li>
<li>读者一写者问题常用于测试新同步原语</li>
</ol>
<h4 id="程序信号量及变量设计"><a href="#程序信号量及变量设计" class="headerlink" title="程序信号量及变量设计"></a>程序信号量及变量设计</h4><ol>
<li><p>写者进程与其它进程的互斥执行</p>
<p>写互斥信号量wmutex,初始值为1</p>
</li>
<li><p>读者进程之间的并发执行</p>
<p>读者进程计数变量readercount,表示正在执行的读者进程数量，其初始值为0</p>
</li>
<li><p>读者进程计数变量的互斥访问</p>
<p>readercounti对于多个读者进程而言是临界资源，应为之设置读互斥信号量rmutex,其初始值为1</p>
</li>
</ol>
<h4 id="主程序设计-6"><a href="#主程序设计-6" class="headerlink" title="主程序设计"></a>主程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var readercount:integer 0;</span><br><span class="line">	rmutex,wmutex:semphore :=1,1;</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		reader;...;readeri ;...readerm;</span><br><span class="line">		writer;..;writerj;..;writern;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="写者子程序设计"><a href="#写者子程序设计" class="headerlink" title="写者子程序设计"></a>写者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">writerj:</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(wmutex);</span><br><span class="line">			Perform write operation;</span><br><span class="line">			signal(wmutex);</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h4 id="读者子程序设计"><a href="#读者子程序设计" class="headerlink" title="读者子程序设计"></a>读者子程序设计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readeri:</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(rmutex);</span><br><span class="line">			if readercount=0 then wait(wmutex);</span><br><span class="line">			readercount:=readercount +1;</span><br><span class="line">			signal(rmutex);</span><br><span class="line">			Perform read operation;</span><br><span class="line">			wait(rmutex);</span><br><span class="line">			readercount:=readercount -1;</span><br><span class="line">			if readercount=0 then signal(wmutex)</span><br><span class="line">			signal(rmutex);</span><br><span class="line">		until false:</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><ol>
<li>如果读者到来<ul>
<li>若为第一个读者：若无写者写，则开始读；否则插入wmutex队列等待</li>
<li>若非第一个读者：若前有读者在读（无论是否有写者已在等待)，新读者均开始读：否则插入rmutex队列[前面读者在等]等待</li>
</ul>
</li>
<li>如果写者到来<ul>
<li>无写者写且无读者读，则新写者开始写</li>
<li>有写者写或有读者读，则插入wmutex队列等待</li>
</ul>
</li>
</ol>
<h4 id="消除读者优先"><a href="#消除读者优先" class="headerlink" title="消除读者优先"></a>消除读者优先</h4><ol>
<li>一旦有写者到达，则后续的读者必须等待（无论当时是否有读者在读）</li>
<li>如果读者到来<ul>
<li>有写者写或有写者等，则新读者等待</li>
<li>无写者写且无写者等，则新读者可读</li>
</ul>
</li>
<li>如果写者到来<ul>
<li>无读者读且无写者写，则新写者可写</li>
<li>有读者读或有写者写，则新写者等待</li>
</ul>
</li>
</ol>
<h4 id="公平型读者-写者"><a href="#公平型读者-写者" class="headerlink" title="公平型读者-写者"></a>公平型读者-写者</h4><h5 id="主程序设计-7"><a href="#主程序设计-7" class="headerlink" title="主程序设计"></a>主程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var readercount:integer 0;</span><br><span class="line">	S,rmutex,wmutex:semphore :=1,1,1;</span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">		reader;...;readeri ;...readerm;</span><br><span class="line">		writer;..;writerj;..;writern;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h5 id="读者子程序设计-1"><a href="#读者子程序设计-1" class="headerlink" title="读者子程序设计"></a>读者子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">readeri:</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(S);</span><br><span class="line">			wait(rmutex);</span><br><span class="line">			if readercount=0 then wait(wmutex);</span><br><span class="line">			readercount:=readercount +1;</span><br><span class="line">			signal(rmutex);</span><br><span class="line">			signal(S);</span><br><span class="line">			Perform read operation;</span><br><span class="line">			wait(rmutex);</span><br><span class="line">			readercount:=readercount -1;</span><br><span class="line">			if readercount=0 then signal(wmutex)</span><br><span class="line">			signal(rmutex);</span><br><span class="line">		until false:</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h5 id="写者子程序设计-1"><a href="#写者子程序设计-1" class="headerlink" title="写者子程序设计"></a>写者子程序设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">writerj:</span><br><span class="line">	begin</span><br><span class="line">		repeat</span><br><span class="line">			wait(S)；</span><br><span class="line">			wait(wmutex);</span><br><span class="line">			Signal(S);</span><br><span class="line">			Perform write operation;</span><br><span class="line">			signal(wmutex);</span><br><span class="line">		until false;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p><strong>程序的执行首先要加载装入到内存，然后程序的运行从内存提取加载到CPU执行，重点如何把程序里的地址转化成内存的物理单元的物理地址</strong></p>
<h3 id="用户程序处理过程"><a href="#用户程序处理过程" class="headerlink" title="用户程序处理过程"></a>用户程序处理过程</h3><p>源程序（符号名空间）</p>
<p><strong>编译程序</strong></p>
<p>目标模块（目标&#x2F;相对地址空间）</p>
<p><strong>链接程序</strong></p>
<p>装入模块（统一的目标地址空间）</p>
<p><strong>装入程序</strong></p>
<p>内存（物理地址空间）</p>
<h3 id="程序处理与内存管理"><a href="#程序处理与内存管理" class="headerlink" title="程序处理与内存管理"></a>程序处理与内存管理</h3><h4 id="程序地址空间及形成"><a href="#程序地址空间及形成" class="headerlink" title="程序地址空间及形成"></a>程序地址空间及形成</h4><ul>
<li>目标模块（由编译&#x2F;汇编得到）：相对地址</li>
<li>链接过程实现各目标模块相对地址的统一</li>
</ul>
<h4 id="内存管理逻辑部件"><a href="#内存管理逻辑部件" class="headerlink" title="内存管理逻辑部件"></a>内存管理逻辑部件</h4><ul>
<li>MMU负责将逻辑地址转换为物理地址</li>
<li>X86体系结构MMU支持分页和分段机制</li>
</ul>
<h4 id="内存管理模式"><a href="#内存管理模式" class="headerlink" title="内存管理模式"></a>内存管理模式</h4><p>实模式和保护模式</p>
<h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><h4 id="INTERFACE（接口、界面、介面）"><a href="#INTERFACE（接口、界面、介面）" class="headerlink" title="INTERFACE（接口、界面、介面）"></a>INTERFACE（接口、界面、介面）</h4><p>接口是连接两个物体的边界，通过这个界面，两边可以很好地对话</p>
<ul>
<li>硬件-硬件：USB、VGA、HDML、</li>
<li>软件-硬件：指令集</li>
<li>软件-软件：Application Programming Interface（API）</li>
</ul>
<h4 id="VIRTUAL-MACHINE"><a href="#VIRTUAL-MACHINE" class="headerlink" title="VIRTUAL MACHINE"></a>VIRTUAL MACHINE</h4><p>操作系统向用户提供一个容易理解和使用的“计算机”（虚拟的)，用户对这个“计算机”的操作都将被操作系统转成对计算机硬件的操作</p>
<h4 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h4><h5 id="用户角度"><a href="#用户角度" class="headerlink" title="用户角度"></a>用户角度</h5><ul>
<li>提供良好的用户界面</li>
<li>标准的函数库</li>
<li>使得编程更加方便并且不<br>容易出错</li>
</ul>
<h5 id="系统角度"><a href="#系统角度" class="headerlink" title="系统角度"></a>系统角度</h5><ul>
<li>管理资源<ul>
<li>硬件资源（处理机，存储器，设备)</li>
<li>信息资源（文件）</li>
</ul>
</li>
<li>解决申请资源时产生的冲突</li>
<li>阻止错误的产生和对计算机不正当的使用</li>
</ul>
<h4 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h4><ol>
<li>操作系统在用户和计算机硬件之间扮演了中间人的角色</li>
<li>操作系统的目标是为提供一个方便高效执行代码的环境</li>
<li>操作系统是管理计算机硬件的软件</li>
</ol>
<h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4><ul>
<li>memory</li>
<li>CPU</li>
<li>disk controller-&gt;disks</li>
<li>mouse、keyboard、printer、monitor-&gt;USB controller</li>
<li>monitor-&gt;graphics adapter(显示适配器)-&gt;显卡</li>
<li>Bus</li>
</ul>
<h5 id="主引导扇区（BOOT-SECTOR）"><a href="#主引导扇区（BOOT-SECTOR）" class="headerlink" title="主引导扇区（BOOT SECTOR）"></a>主引导扇区（BOOT SECTOR）</h5><ol>
<li>硬盘的0柱面、0磁头、1扇区称为主引导扇区，在这扇区里存放着一段代码：主引导记录MBR(Main Boot Record),它用于硬盘启动时将系统控制权转给用户指定的、在分区表中登记了某个操作系统分区</li>
<li>MBR的内容是在硬盘分区时由分区软件写入该扇区的，MBR不属于任何一个操作系统，不随操作系统的不同而不同，即使不同，MBR也不会夹带操作系统的性质，具有公共引导的特性</li>
</ol>
<h5 id="BOOTSTRAP-gt-OS自己把自己拉启动"><a href="#BOOTSTRAP-gt-OS自己把自己拉启动" class="headerlink" title="BOOTSTRAP-&gt;OS自己把自己拉启动"></a>BOOTSTRAP-&gt;OS自己把自己拉启动</h5><p>Pull oneself up by one’s bootstraps.</p>
<h5 id="BOOTSTRAP-OF-COMPUTER"><a href="#BOOTSTRAP-OF-COMPUTER" class="headerlink" title="BOOTSTRAP OF COMPUTER"></a>BOOTSTRAP OF COMPUTER</h5><ul>
<li>打开电源</li>
<li>CPU将控制权交给BIOS（基本输入输出系统，存放在CMOS中)</li>
<li>BIOS运行一个程序：通电自测试程序</li>
<li>BIOS确认所有外部设备：硬盘或扩充卡</li>
<li>BIOS找到磁盘的引导区，将其中的主引导程序bootloader装入内存。（主引导程序是一段代码，它可以将OS余下部分装入内存)</li>
<li>引导操作系统结束，操作系统接管计算机</li>
<li>操作系统等待事件发生…</li>
</ul>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul>
<li>当有事件（Event)发生时，CPU会收到一个中断(Interrupt)信号，可以是硬中断也可以是软件中断。</li>
<li>CPU会停下正在做的事，转而执行中断处理程序执行完毕会回到之前被中断的地方继续执行。</li>
<li>操作系统是一个以中断驱动的系统</li>
</ul>
<h5 id="STORAGE-SYSTEM-存储系统"><a href="#STORAGE-SYSTEM-存储系统" class="headerlink" title="STORAGE SYSTEM(存储系统)"></a>STORAGE SYSTEM(存储系统)</h5><ol>
<li>CPU负责将指令(Instruction)从内存（Memory)读入，所以程序必须在内存中才能运行。</li>
<li>内存以字节为存储单位，每个字节都有一个地址与之对应。通过load&#x2F;store:指令即可访问指定地址的内存数据<ul>
<li>load:将内存数据装入寄存器(Register)</li>
<li>store:将寄存器数据写入内存</li>
</ul>
</li>
</ol>
<h5 id="I-x2F-O结构"><a href="#I-x2F-O结构" class="headerlink" title="I&#x2F;O结构"></a>I&#x2F;O结构</h5><ul>
<li>存储器只是众多IO设备中的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且他有着很强的扩展性。</li>
<li>管理IO设备是操作系统非常重要的组成部分，操作系统中有一个专门的O子系统负责完成这项工作。</li>
</ul>
<h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><h5 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h5><ul>
<li>Single-processor System</li>
<li>只有一颗主CPU,执行通用指令集。</li>
<li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等。<ul>
<li>它们能够执行的指令有限，不处理用户进程</li>
<li>操作系统会向它们发出任务，并监控它们的状态</li>
</ul>
</li>
</ul>
<h5 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h5><ul>
<li>Multiprocessor&#x2F;Multicore System</li>
<li>有两个或多个紧密通信的CPU,它们共享计算机总线、时钟、内存和外设等。<ul>
<li>非对称处理(Asymmetric multiprocessing)<br>对称处理(Symmetric MuliProcessing)</li>
</ul>
</li>
</ul>
<h5 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h5><ul>
<li>Clustered System</li>
<li>该系统由若干节点（node)通过网络连接在一起每个节点可为单处理器系统或多处理器系统，节点之间是松耦合(loosely coupled)关系。<ul>
<li>高可用性(high availability)</li>
<li>高性能计算(high-performance computing)</li>
</ul>
</li>
</ul>
<h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><h5 id="单用户单模式"><a href="#单用户单模式" class="headerlink" title="单用户单模式"></a>单用户单模式</h5><p>输入500个字符（花78ms),经CPU处理52ms后，将结果2000个字符存到磁带上（花20ms),重复进行。CPU利用率&#x3D;52&#x2F;(78+52+20)≈35%</p>
<h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h5><ul>
<li>操作系统最重要的一点是具有多道程序(multiprogramming)能力。</li>
<li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用得CPU总有一个执行任务，从而提高CPU利用率。</li>
<li>实现的硬件保证：处理器和IO设备具备并行工作的能力</li>
</ul>
<h5 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h5><ul>
<li>分时系统（time sharing)也称多任务系统(multi-tasking)，是多道程序设计的自然延伸。</li>
<li>允许多个用户共享一台计算机<ul>
<li>用户只有输入和输出设备</li>
<li>分时系统为每个用户轮流分配等量的CPU时间</li>
<li>用户从发出指令到得到即时结果的时间称为响应时间</li>
</ul>
</li>
<li>第一个分时系统CTSS由MIT于1962年开发出来</li>
</ul>
<h5 id="引发的其他模式"><a href="#引发的其他模式" class="headerlink" title="引发的其他模式"></a>引发的其他模式</h5><ul>
<li>处理器调度（CPU Scheduling)</li>
<li>交换(Swapping）</li>
<li>虚拟内存(Virtual Memory)</li>
<li>磁盘管理（Disk Management）</li>
<li>同步(Synchronization)</li>
<li>死锁(Deadlock)</li>
</ul>
<h3 id="操作系统提供的服务"><a href="#操作系统提供的服务" class="headerlink" title="操作系统提供的服务"></a>操作系统提供的服务</h3><h4 id="USER-INTERFACE"><a href="#USER-INTERFACE" class="headerlink" title="USER INTERFACE"></a>USER INTERFACE</h4><p>Almost all operating system have a user interface(UI).It offers a way for users to interface（交互） with OS.</p>
<h5 id="CLI（Command-Line-Interface）（命令行）"><a href="#CLI（Command-Line-Interface）（命令行）" class="headerlink" title="CLI（Command Line Interface）（命令行）"></a>CLI（Command Line Interface）（命令行）</h5><p>command interpreter(shell)命令解释器</p>
<h5 id="GUI-Graphic-User-Interface"><a href="#GUI-Graphic-User-Interface" class="headerlink" title="GUI(Graphic User Interface)"></a>GUI(Graphic User Interface)</h5><p>A user friendly graphical user interface.</p>
<h5 id="Batch-批处理"><a href="#Batch-批处理" class="headerlink" title="Batch(批处理)"></a>Batch(批处理)</h5><ul>
<li>It is a file which contains commands and directives.</li>
<li>Demonstration …</li>
</ul>
<h4 id="系统调用（SYSTEM-CALLS）"><a href="#系统调用（SYSTEM-CALLS）" class="headerlink" title="系统调用（SYSTEM CALLS）"></a>系统调用（SYSTEM CALLS）</h4><ol>
<li>系统调用提供了访问和使用操作系统所提供的服务的接口<ul>
<li>系统调用的实现代码是操作系统级的</li>
<li>这个接口通常是面向程序员的</li>
</ul>
</li>
<li>API(Application Programming Interface)):指明了参数和返回值的一组函数。<ul>
<li>应用程序App的开发人员通过透过API间接访问了系统调用</li>
<li>Windows API POSIX API JAVA API</li>
</ul>
</li>
</ol>
<h5 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h5><ul>
<li>每个系统调用都有一个唯一的数字编号，被称为系统调用</li>
<li>用户代码调用API时，API中会向系统调用接口指明其所要用的系统调用号，操作系统内核中维护了一张索引表，依据这个调用号可以检索到访系统调用代码在内核中的位置。</li>
</ul>
<h4 id="双重模式（DUAL-MODE）"><a href="#双重模式（DUAL-MODE）" class="headerlink" title="双重模式（DUAL MODE）"></a>双重模式（DUAL MODE）</h4><ol>
<li>现代计算机系统有一个特殊的硬件，用于划分系统的运行状态，至少需要两种单独运行模式：<ul>
<li>用户模式(user mode)：执行用户代码</li>
<li>内核模式(kernel mode):执行操作系统代码</li>
</ul>
</li>
<li>目的：确保操作系统正确的运行</li>
<li>实现方式：用一个硬件模式位来表示当前模式：0表示内核模式，1<br>表示用户模式。</li>
</ol>
<h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><h4 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h4><ul>
<li>A program is a passive entity,such as a file containing a list of instructions stored on disk(often called an executable file).</li>
<li>A program becomes a process when an executable file is loaded into memory.</li>
<li>A process is an active entity,with a program counter specifying the next instruction to execute an a set of associated resources</li>
</ul>
<h4 id="PROGRAM-COUNTER"><a href="#PROGRAM-COUNTER" class="headerlink" title="PROGRAM COUNTER"></a>PROGRAM COUNTER</h4><ul>
<li>程序计数器(PC)是一个CPU中的寄存器，里面存放下一条要执行指令的内存地址<br>在Intel x86和Itanium微处理器中，它叫做指令指针（Instruction Pointer,IP），有时又称为指令地址寄存器(instruction address register,IAR)、指令计数器</li>
<li>通常，CPU在取完一条指令之后会将PC寄存器的值加“1”，以计算下条要执行指令的地址。</li>
</ul>
<h4 id="PROCESS-IN-MEMORY"><a href="#PROCESS-IN-MEMORY" class="headerlink" title="PROCESS IN MEMORY"></a>PROCESS IN MEMORY</h4><ul>
<li>text：代码</li>
<li>data：全局和静态变量</li>
<li>stack：栈用于存放局部变量、函数返回地址</li>
<li>heap：堆用于程序运行时的动态内存分配</li>
</ul>
<h4 id="并发的进程"><a href="#并发的进程" class="headerlink" title="并发的进程"></a>并发的进程</h4><ul>
<li>Concurrency:the fact of two or more events or circumstances happening（存在） or existing at the same time.</li>
<li>并行：running at the same time</li>
<li>并发进程可能无法一次性执行完毕，会<strong>走走停停</strong>。</li>
<li>一个进程在执行过程中可能会被另一个进程替换占有CPU,这个过程称作“<strong>进程切换</strong>”</li>
</ul>
<h4 id="进程的定义-1"><a href="#进程的定义-1" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol>
<li>进程是一个程序的一次执行过程<ul>
<li>能够具体完成的</li>
<li>是在某个数据集合上完成的</li>
<li>执行过程是可并发的</li>
</ul>
</li>
<li>进程是资源分配、保护和调度的基本单位</li>
</ol>
<h4 id="进程状态（PROCESS-STATE）"><a href="#进程状态（PROCESS-STATE）" class="headerlink" title="进程状态（PROCESS STATE）"></a>进程状态（PROCESS STATE）</h4><p>进程在执行期间自身的状态会发生变化，进程有三种基本状态，分别是：</p>
<ol>
<li>运行态(Running)：此时进程的代码在CPU上运行</li>
<li>就绪态(Ready):进程具备运行条件，等待分配CPU</li>
<li>等待态(Waiting)：进程在等待某些事件的发生（比如IO操作结束或是一个信号)</li>
</ol>
<h4 id="进程何时离开CPU"><a href="#进程何时离开CPU" class="headerlink" title="进程何时离开CPU"></a>进程何时离开CPU</h4><ol>
<li>内部事件<ul>
<li>进程<strong>主动放弃</strong>（yield）CPU，进入等待&#x2F;终止状态</li>
<li>例如使用I&#x2F;O设备，（非）正常结束如除以0</li>
</ul>
</li>
<li>外部事件<ul>
<li>进程被剥夺CPU使用权，进入就绪状态。这个动作叫<strong>抢占</strong>(preempt)。</li>
<li>例如时间片到达，高优先权进程到达。</li>
</ul>
</li>
</ol>
<h3 id="进程切换和进程调度"><a href="#进程切换和进程调度" class="headerlink" title="进程切换和进程调度"></a>进程切换和进程调度</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>并发进程中，一个进程在执行过程中可能会被另一个进程替换占有CPU,这个过程称作“<strong>进程切换</strong>”。</p>
<h4 id="中断技术（Interrupt）"><a href="#中断技术（Interrupt）" class="headerlink" title="中断技术（Interrupt）"></a>中断技术（Interrupt）</h4><p>中断是指程序执行过程中</p>
<ul>
<li>当发生某个事件时，中止CPU上现行程序的运行</li>
<li>引出该事件的处理程序执行</li>
<li>执行完毕返回源程序中断点继续执行</li>
</ul>
<h4 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h4><h5 id="外中断（interrupt）"><a href="#外中断（interrupt）" class="headerlink" title="外中断（interrupt）"></a>外中断（interrupt）</h5><p>来自处理器之外的硬件中断信号</p>
<ul>
<li>如时钟中断、键盘中断、外围设备中断</li>
<li>外部中断均是异步中断</li>
</ul>
<h5 id="内中断（异常Exception）"><a href="#内中断（异常Exception）" class="headerlink" title="内中断（异常Exception）"></a>内中断（异常Exception）</h5><p>来自于处理器内部，指令执行过程中发生的中断，属同步中断</p>
<ul>
<li>硬件异常：掉电、奇偶校验错误等</li>
<li>程序异常：非法操作、地址越界、断点、除数为0</li>
<li>系统调用</li>
</ul>
<h4 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h4><h5 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h5><p>只能在内核态运行的指令</p>
<ul>
<li>I&#x2F;O指令和停止整个系统指令</li>
<li>关闭所有中断</li>
<li>设置定时器</li>
<li>进程切换</li>
</ul>
<h5 id="非特权指令"><a href="#非特权指令" class="headerlink" title="非特权指令"></a>非特权指令</h5><p>只能运行在用户态</p>
<h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><ul>
<li>中断是用户态向核心态转换的唯一途径！系统调用实质上也是一种中断</li>
<li>OS提供LoadPSW指令装载用户进程返回用户状态</li>
</ul>
<h4 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h4><h5 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h5><ul>
<li>进程需要进入等待状态</li>
<li>进程被抢占CPU而进入就绪状态</li>
</ul>
<h5 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h5><ul>
<li>CPU从用户态切换到核心态</li>
<li>保存被中断进程的上下文信息（Context）</li>
<li>修改被中断进程的控制信息（如状态等）</li>
<li>将被中断的进程加入相应的状态队列</li>
<li>调度一个新的进程并恢复它的上下文信息</li>
</ul>
<p><strong>进程的上下文包含了进程在内存中的text、data、heap、stack和PCB</strong></p>
<p>运行实体：text、data、heap、stack</p>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>PCB包含了一个指定进程的许多信息，包括如下</p>
<ul>
<li>进程状态</li>
<li>进程编号PID</li>
<li>PC值</li>
<li>寄存器的值</li>
<li>内存信息</li>
<li>打开的文件</li>
</ul>
<h4 id="进程调度（PROCESS-SCHEDULING）"><a href="#进程调度（PROCESS-SCHEDULING）" class="headerlink" title="进程调度（PROCESS SCHEDULING）"></a>进程调度（PROCESS SCHEDULING）</h4><p>进程在整个生命周期中会在各个调度队列中迁移，由操作系统的一个调度器（scheduler）来执行。</p>
<h4 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h4><p>用于创建一个新进程，该进程为当前进程的子进程，创建的方法：fork（）；</p>
<p>父进程在执行了fork后，将当前进程在内存中的所有数据原模原样复制一份，从fork（）开始并发执行fork（）之后的所有代码</p>
<p>fork（）的返回值：</p>
<ul>
<li>如果成功创建子进程，对于父子进程fork会返回不同的值，</li>
<li>对于父进程它的返回值是子进程的进程id值</li>
<li>对于子进程它的返回值是0</li>
<li>如果创建失败，返回值为-1</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>进程中的执行流</p>
<ul>
<li>A thread is a basic unit of CPU utilization(利用）;it comprises a thread id,a program counter,a register set,and a stack</li>
<li>It shares with other threads belonging to the same process its code section,data section,and other operating-system resources,such as open files and signals（共享）</li>
<li>A traditional (or heavyweight（重量级）)process has a single thread of control,If a process has multiple threads（lightweight轻量级 ）of control,it can perform more than one task at a time.</li>
</ul>
<h4 id="采用多线程的优点"><a href="#采用多线程的优点" class="headerlink" title="采用多线程的优点"></a>采用多线程的优点</h4><ul>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性</li>
</ul>
<h4 id="多核编程"><a href="#多核编程" class="headerlink" title="多核编程"></a>多核编程</h4><p>在多处理器系统中，多核编程机制让应用程序可以更有效地将自身的多个执行任务（并发的线程）分散到不同的处理器上运行，以实现并行计算</p>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li><p>用户线程ULT(User Level Thread)</p>
<p>ULT在user mode下运行，它的管理无需内核支持。</p>
</li>
<li><p>内核线程KLT(Kernel Level Thread)<br>KLT在kernel mode下运行，由操作系统支持与管理。</p>
</li>
</ul>
<h3 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>多道程序设计的目的将CPU的利用率最大化。</li>
<li>多个进程同时存在于内存(并发)，当一个进程暂不使用CPU时，系统调度另一个进程占用CPU。</li>
</ul>
<h4 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h4><p>Whenever the CPU becomes idle（空闲）,the operating system must select one of the processes in the ready queue to be executed.The selection process is carried out by the CPU scheduler.</p>
<h4 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h4><p>非抢占调度（Nonpreemptive scheduling）</p>
<p>一旦某个进程得到CPU,就会一直占用到终止或等待状态。</p>
<p>抢占调度(Preemptive scheduling)</p>
<h4 id="调度算法性能的衡量"><a href="#调度算法性能的衡量" class="headerlink" title="调度算法性能的衡量"></a>调度算法性能的衡量</h4><ul>
<li>CPU利用率：CPU的忙碌程度</li>
<li>响应时间：从提交任务到第一次响应的时间（针对交互式系统）</li>
<li>等待时间：进程<strong>累积</strong>在就绪队列中等待的时间</li>
<li>周转时间：从提交到完成的时间</li>
<li>吞吐率：每个时钟单位处理的任务数</li>
<li>公平性：以合理的方式让各个进程共享CPU</li>
</ul>
<h4 id="调度性能指标"><a href="#调度性能指标" class="headerlink" title="调度性能指标"></a>调度性能指标</h4><ul>
<li>作业（job）&#x3D;进程(process）</li>
<li>假设作业提交给系统的时刻是ts,完成的时刻是tf,所需运行时间为tk,那么：</li>
<li>平均作业周转时间T(ti是单个作业的周转时间)</li>
<li>T&#x3D;求和ti（i&#x3D;1…n）×1&#x2F;n（ti&#x3D;tf-ts）</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先来先服务（FCFS-x2F-FIFO）"><a href="#先来先服务（FCFS-x2F-FIFO）" class="headerlink" title="先来先服务（FCFS&#x2F;FIFO）"></a>先来先服务（FCFS&#x2F;FIFO）</h5><ul>
<li><p>First-Come,First-Served(FCFS)</p>
<ul>
<li>早期系统里，FCFS意味着一个程序会一直运行到结束（尽管其中会出现等待I&#x2F;O的情况)</li>
<li>如今，当一个程序阻塞时会让出CPU</li>
</ul>
</li>
<li><p>例题</p>
<table>
<thead>
<tr>
<th>process</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>28</td>
</tr>
<tr>
<td>P2</td>
<td>9</td>
</tr>
<tr>
<td>P3</td>
<td>3</td>
</tr>
</tbody></table>
<p>如果三个进程的到达顺序是：P1,P2,P3</p>
</li>
<li><p>等待时间分别是：P1&#x3D;0;P2&#x3D;28;P3&#x3D;37</p>
</li>
<li><p>平均等待时间是：(0+28+37)&#x2F;3&#x3D;22</p>
</li>
<li><p>平均作业周转时间是：(28+37+40)&#x2F;3&#x3D;35</p>
</li>
</ul>
<h6 id="先来先服务（续）"><a href="#先来先服务（续）" class="headerlink" title="先来先服务（续）"></a>先来先服务（续）</h6><p>如果换一种执行顺序的话：P3,P2,P1</p>
<ul>
<li>等待时间分别是：P1&#x3D;12；P2&#x3D;3;P3&#x3D;0</li>
<li>平均等待时间是：(12+3+0)&#x2F;3</li>
<li>平均周转时间是：(3+12+40)&#x2F;3&#x3D;18</li>
</ul>
<p>第二种排列方式比第一种要好，平均周转时间缩短为18</p>
<h6 id="先来先服务优缺点"><a href="#先来先服务优缺点" class="headerlink" title="先来先服务优缺点"></a>先来先服务优缺点</h6><ul>
<li>简单易行(+)</li>
<li>如果短作业处在长作业的后面将导致周围时间变长（-）。</li>
</ul>
<h5 id="时间片轮转（ROUND-ROBIN）"><a href="#时间片轮转（ROUND-ROBIN）" class="headerlink" title="时间片轮转（ROUND ROBIN）"></a>时间片轮转（ROUND ROBIN）</h5><p>针对分时系统</p>
<ul>
<li><p>每个进程都可以得到相同的CPU时间(CPU时间片，time slice),当时间片到达，进程将被剥夺CPU并加入就绪队列的尾部</p>
</li>
<li><p>抢占式调度算法P</p>
</li>
<li><p>n个就绪队列中的进程和时间片q→</p>
<ul>
<li>每个进程获得1&#x2F;n的CPU时间，大约是q个时间单位</li>
<li>没有进程等待时间会超过(n-1)q</li>
</ul>
</li>
<li><p>例题（时间片&#x3D;20）</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>CPU Time</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>68</td>
</tr>
<tr>
<td>P2</td>
<td>53</td>
</tr>
<tr>
<td>P3</td>
<td>24</td>
</tr>
<tr>
<td>P4</td>
<td>8</td>
</tr>
</tbody></table>
<ul>
<li><p>等待时间分别是：</p>
<p>P1&#x3D;(68-20)+(112-88)+(145-32)&#x3D;85<br>P2&#x3D;(20-0)+(88-40)+(132-108)&#x3D;92<br>P3&#x3D;(40-0)+(108-60)&#x3D;88<br>P4&#x3D;(60-0)&#x3D;60</p>
</li>
<li><p>平均等待时间&#x3D;(85+92+88+60)&#x2F;4&#x3D;81.25</p>
</li>
<li><p>平均周转时间&#x3D;(153+145+112+68)&#x2F;4&#x3D;119.5</p>
</li>
<li><p>如果采用FCFS算法，平均等待时间83.5，平均周转时间121.75</p>
</li>
</ul>
</li>
</ul>
<h6 id="RR算法分析"><a href="#RR算法分析" class="headerlink" title="RR算法分析"></a>RR算法分析</h6><ol>
<li>时间片（time slice）取选<ul>
<li>取值太小：进程切换开销显著增大（不能小于进程切换的时间）</li>
<li>取值较大：响应速度下降（取值无穷大将退化成FCFS)</li>
<li>一般时间片的选取范围为10ms~100ms</li>
<li>上下文切换的时间大概为0.1ms~1ms（1%的CPU时间开销)</li>
</ul>
</li>
<li>RR算法优缺点<ul>
<li>公平算法(+)</li>
<li>对长作业带来额外的切换开销(-)</li>
</ul>
</li>
<li>RR不一定优于FCFS</li>
</ol>
<h5 id="最短作业优先（SJF）"><a href="#最短作业优先（SJF）" class="headerlink" title="最短作业优先（SJF）"></a>最短作业优先（SJF）</h5><ul>
<li>SJF(Shortest Job First)):下一次调度总是选择所需要CPU时间最短的那个作业（进程)。</li>
<li>抢占式SRTF</li>
</ul>
<h6 id="SJF-x2F-SRTF算法分析"><a href="#SJF-x2F-SRTF算法分析" class="headerlink" title="SJF&#x2F;SRTF算法分析"></a>SJF&#x2F;SRTF算法分析</h6><ul>
<li>该算法总是将短进程移到长进程之前执行，因此平均等待时间最小，该算法被证明是最优的。</li>
<li>饥饿现象：长进程可能长时间无法获得CPU</li>
<li>预测技术<ul>
<li>该算法需要事先知道进程所需的CPU时间</li>
<li>预测一个进程的CPU时间并非易事</li>
</ul>
</li>
<li>优缺点<ul>
<li>优化了响应时间(+)</li>
<li>难以预测作业CPU时间(-)</li>
<li>不公平算法(-)</li>
</ul>
</li>
</ul>
<h5 id="优先级调度（PRIORITY）"><a href="#优先级调度（PRIORITY）" class="headerlink" title="优先级调度（PRIORITY）"></a>优先级调度（PRIORITY）</h5><p>优先级通常为固定区间的数字，如[0,10]：</p>
<ul>
<li>数字大小与优先级高低的关系在不同系统中实现不一样，以Linux为例，0为最高优先级。</li>
<li>调度策略：下一次调度总是选择优先级最高的进程。</li>
<li>SJF是优先级调度的一个特例。</li>
<li>优先级调度可以是抢占式，也可以是非抢占式。</li>
</ul>
<h6 id="优先级的定义"><a href="#优先级的定义" class="headerlink" title="优先级的定义"></a>优先级的定义</h6><ol>
<li><p>静态优先级</p>
<p>优先级保持不变，但会出现不公平（饥饿）现象</p>
</li>
<li><p>动态优先级（退化Aging）</p>
<ul>
<li>根据进程占用CPU时间：当进程占有CPU时间愈长，则<br>慢慢降低它的优先级；</li>
<li>根据进程等待CPU时间：当进程在就绪队列中等待时间<br>愈长，则慢慢提升它的优先级。</li>
</ul>
</li>
<li><p>现代操作系统采用动静态结合的优先级</p>
</li>
</ol>
<h3 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="并发进程-x2F-线程"><a href="#并发进程-x2F-线程" class="headerlink" title="并发进程&#x2F;线程"></a>并发进程&#x2F;线程</h4><p>在内存中同时存在的若干个进程&#x2F;线程，由操作系统的调度程序采用适当的策略将他（们）调度至CPU(s)上运行，同时维护他们的状态队列。</p>
<ul>
<li>多个并发进程&#x2F;线程从宏观上是同时在运行；</li>
<li>从微观上看，他们的运行过程是走走停停：</li>
<li>并发的进程&#x2F;线程之间是<strong>交替执行(Interleaving)。</strong></li>
</ul>
<h4 id="并发进程之间的关系"><a href="#并发进程之间的关系" class="headerlink" title="并发进程之间的关系"></a>并发进程之间的关系</h4><ol>
<li>独立关系<ul>
<li>并发进程分别在自己的变量集合上运行</li>
<li>例如：chrome进程和music进程</li>
</ul>
</li>
<li>交互关系<ul>
<li>并发进程执行过程中需要共享或是交换数据</li>
<li>例如：银行交易服务器上的receiver:进程和handler:进程</li>
<li>交互的并发进程之间又存在着<strong>竞争</strong>和<strong>协作</strong>的关系</li>
</ul>
</li>
</ol>
<h4 id="竞争（RACE）"><a href="#竞争（RACE）" class="headerlink" title="竞争（RACE）"></a>竞争（RACE）</h4><h4 id="协作（COOPERATION）"><a href="#协作（COOPERATION）" class="headerlink" title="协作（COOPERATION）"></a>协作（COOPERATION）</h4><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>Asynchronous means RANDOM!</li>
<li>会引发竞争条件(Race Condition)：一种这样的情况：多个进程并发操作同一个数据导致执行结果依赖于特定的进程执行顺序。</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li>Process Synchronization means a mechanism（机制） to maintain（维护） the consistency（一致性） of data shared in cooperative processes.</li>
<li>Synchronization Tool Kits<ul>
<li>Mutex lock(互斥锁)</li>
<li>Semaphore（信号量）</li>
</ul>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="临界区问题（CRITICAL-SECTION-PROBLEM）"><a href="#临界区问题（CRITICAL-SECTION-PROBLEM）" class="headerlink" title="临界区问题（CRITICAL-SECTION PROBLEM）"></a>临界区问题（CRITICAL-SECTION PROBLEM）</h4><ul>
<li>Each concurrent(并发) process has a segment of code,called a <strong>critical section</strong>,in which the process may be changing <strong>common variables</strong>（公共数据）,updating a table,writing a file,and so on.</li>
<li>The important feature of the system is that,when one process is executing in its critical section,no other process is allowed to execute in its critical section.That is,<strong>NO</strong> two processes are executing in their critical sections <strong>at the same time</strong>.</li>
<li><strong>The critical-section problem</strong> is to design a protocol（协议） that the processes can use to cooperate.</li>
</ul>
<h4 id="进程进出临界区协议"><a href="#进程进出临界区协议" class="headerlink" title="进程进出临界区协议"></a>进程进出临界区协议</h4><ul>
<li>进入临界区前在entry section要请求许可；</li>
<li>离开临界区后在exit section要归还许可。</li>
</ul>
<h4 id="临界区管理准则"><a href="#临界区管理准则" class="headerlink" title="临界区管理准则"></a>临界区管理准则</h4><ul>
<li>Mutual exclusion(Mutex):互斥</li>
<li>Progress:前进</li>
<li>Bounded waiting:有限等待</li>
</ul>
<p>简而言之</p>
<ul>
<li>有空让进</li>
<li>择一而入</li>
<li>无空等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h4 id="软件解决临界区管理"><a href="#软件解决临界区管理" class="headerlink" title="软件解决临界区管理"></a>软件解决临界区管理</h4><ul>
<li>实现需要较高的编程技巧</li>
<li>两个进程的实现代码是不对称的，当处理超过2个进程的时候，代码的复杂度会变得更大</li>
<li>两个著名的软件方案<ul>
<li>Peterson</li>
<li>Dekker</li>
</ul>
</li>
</ul>
<h4 id="MUTEX-LOCKS"><a href="#MUTEX-LOCKS" class="headerlink" title="MUTEX LOCKS"></a>MUTEX LOCKS</h4><p>Operating-systems designers build software tools to solve the critical-section problem.The simplest of these tools is the mutex lock.</p>
<ul>
<li>A process must acquire the lock before entering a critical section;</li>
<li>It must release the lock when it exits the critical section.</li>
</ul>
<h4 id="锁的基本操作"><a href="#锁的基本操作" class="headerlink" title="锁的基本操作"></a>锁的基本操作</h4><ul>
<li>上锁<ul>
<li>等待锁至打开状态</li>
<li>获取锁并锁上</li>
</ul>
</li>
<li>解锁</li>
<li>原子操作</li>
</ul>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><ul>
<li><strong>Atomic operations</strong> mean the operation can <strong>NOT</strong> be interrupted while it’s running.</li>
<li>原子操作（愿语）是操作系统重要的组成部分，下面2条硬件指令都是原子操作，它们可以被用来实现对临界区的管理（也就是“锁”)。<ul>
<li>test_and _set()</li>
<li>compare_and_swap()</li>
</ul>
</li>
</ul>
<h4 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool available = true;//unlocked</span><br><span class="line">lock()&#123;</span><br><span class="line">	while(!ts(&amp;available))</span><br><span class="line">       do nothing;</span><br><span class="line">&#125;</span><br><span class="line">unlock()&#123;</span><br><span class="line">	available = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原子操作</span><br><span class="line">bool ts(bool *target)&#123;</span><br><span class="line">	bool result =*target</span><br><span class="line">	*target = false;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="忙式等待（BUSY-WAITING）"><a href="#忙式等待（BUSY-WAITING）" class="headerlink" title="忙式等待（BUSY WAITING）"></a>忙式等待（BUSY WAITING）</h4><ul>
<li>忙式等待是指占用CPU执行空循环实现等待</li>
<li>这种类型的互斥锁也被称为“自旋锁”(spin lock)<ul>
<li>缺点：浪费CPU周期，可以将进程插入等待队列以让出CPU的使用权；</li>
<li>优点：进程在等待时没有上下文切换，对于使用锁时间不长的进程，自旋锁还是可以接受的；在多处理器系统中，自旋锁的优势更加明显。</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h4><ul>
<li>信号量(Semaphore)是一种比互斥锁更强大的同步工具，它可以提供更高级的方法来同步并发进程。<ul>
<li>1965年由荷兰学者Dijkstra提出</li>
</ul>
</li>
<li>A semaphore S is an integer variable（整型变量） that,apart from initialization（初始化赋值）,is accessed only through two standard atomic operations:P(proberen in Dutch)（测试）and V(verhogen in Dutch)（增加）.<ul>
<li>P：wait（）operation</li>
<li>V：signal（）operation</li>
</ul>
</li>
</ul>
<h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(s)&#123;</span><br><span class="line">	while(s&lt;=0)</span><br><span class="line">		do nothing;</span><br><span class="line">	S--;</span><br><span class="line">&#125;</span><br><span class="line">V(s)&#123;</span><br><span class="line">	S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><h5 id="BINARY-SEMAPHORE"><a href="#BINARY-SEMAPHORE" class="headerlink" title="BINARY SEMAPHORE"></a>BINARY SEMAPHORE</h5><p>顾名思义，二值信号量的值只能是0或1，通常将其初始化为1，用于实现互斥锁的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">process pi&#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	critical section</span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="COUNTING-SEMAPHORE"><a href="#COUNTING-SEMAPHORE" class="headerlink" title="COUNTING SEMAPHORE"></a>COUNTING SEMAPHORE</h5><p>一般信号量的取值可以是任意数值，用于控制并发进程对共享资源的访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">semaphore road = 2;</span><br><span class="line">process Cari&#123;</span><br><span class="line">	P(road);</span><br><span class="line">	pass the fork</span><br><span class="line">	in the road.</span><br><span class="line">	V(road);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>信号量初始值&#x3D;0，用于进程同步</strong></p>
<h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><ul>
<li>同步问题实质是将异步的并发进程按照某种顺序执行</li>
<li>解决同步的本质就是要找到并发进程的交互点，利用P操作的等待特点来调节进程的执行速度；</li>
<li>通常初始值为0的信号量可以让进程直接进行等待状态，直到另一个进程唤醒他。</li>
</ul>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="生产-消费者问题"><a href="#生产-消费者问题" class="headerlink" title="生产-消费者问题"></a>生产-消费者问题</h4><p>生产者(P)与消费者(C)共用一个缓冲区，生产者不能往“满”的缓冲区中放产品，消费者不能从“空”的缓冲区中取产品。</p>
<h5 id="单缓冲解决方案"><a href="#单缓冲解决方案" class="headerlink" title="单缓冲解决方案"></a>单缓冲解决方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Semaphore empty = 1;</span><br><span class="line">//signal for producer</span><br><span class="line">Semaphore full = 0;</span><br><span class="line">//signal for consumer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">	while (true)&#123;</span><br><span class="line">		make a product;</span><br><span class="line">		P(empty);</span><br><span class="line">		put the product into buffer;</span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">	while (true)&#123;</span><br><span class="line">		P(full);</span><br><span class="line">		pick product from buffer;</span><br><span class="line">		V(empty);</span><br><span class="line">		consume the product;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有界缓冲区（THE-BOUNDED-BUFFER-PROBLEM）"><a href="#有界缓冲区（THE-BOUNDED-BUFFER-PROBLEM）" class="headerlink" title="有界缓冲区（THE BOUNDED-BUFFER PROBLEM）"></a>有界缓冲区（THE BOUNDED-BUFFER PROBLEM）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">item B[k];</span><br><span class="line">semaphore empty = k;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">int in = 0,out =0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line"></span><br><span class="line">Process producer_i&#123;</span><br><span class="line">	make a product;</span><br><span class="line">	P(empty);</span><br><span class="line">	P(mutex);</span><br><span class="line">	B[in] = product;</span><br><span class="line">	in=（in+1)%k;</span><br><span class="line">	V(mutex);</span><br><span class="line">	V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process consumeri&#123;</span><br><span class="line">	P(full);</span><br><span class="line">	P(mutex);</span><br><span class="line">	product = B[out];</span><br><span class="line">	out=（out+1)%k;</span><br><span class="line">	V(mutex);</span><br><span class="line">	V(empty);</span><br><span class="line">	consume a product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>不要随意扩大临界区</p>
</li>
<li><p>同步信号量：empty和full的PV操作不在同一进程</p>
<p>互斥信号量：mutex的PV操作在同一进程</p>
</li>
</ol>
<h4 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><ul>
<li>桌上有一只盘子，每次只能放入一只水果</li>
<li>爸爸专向盘子中放苹果，妈妈专向盘子中放桔子</li>
<li>儿子专等吃盘子中的桔子，女儿专等吃盘子里的苹果</li>
</ul>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore sp = 1;/*盘子里允许放一个水果*/</span><br><span class="line">semaphore sg1 = 0;/*盘子里没有桔子*/</span><br><span class="line">semaphore sg2 = 0；/*盘子里没有苹果*/</span><br><span class="line"></span><br><span class="line">Process father&#123;</span><br><span class="line">	削一个苹果；</span><br><span class="line">	P(sp);</span><br><span class="line">	把苹果放入plate;</span><br><span class="line">	V(sg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process daughter&#123;</span><br><span class="line">	P(sg2);</span><br><span class="line">	从plate中取苹果；</span><br><span class="line">	V(sp);</span><br><span class="line">	吃苹果；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process mother&#123;</span><br><span class="line">	剥一个桔子；</span><br><span class="line">	P(sp)；</span><br><span class="line">	把桔子放入plate；</span><br><span class="line">	V(sg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process son&#123;</span><br><span class="line">	P(sg1);</span><br><span class="line">	从plate中取桔子；</span><br><span class="line">	V(sp);</span><br><span class="line">	吃桔子；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读者-写者问题（Reader，Writer）"><a href="#读者-写者问题（Reader，Writer）" class="headerlink" title="读者-写者问题（Reader，Writer）"></a>读者-写者问题（Reader，Writer）</h4><h5 id="Rules"><a href="#Rules" class="headerlink" title="Rules:"></a>Rules:</h5><ol>
<li>R和W：竞争</li>
<li>W和W：竞争</li>
<li>R和R：共享&#x2F;同时</li>
</ol>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Semaphore rw=1;</span><br><span class="line">int reader_count=0;//正在读文件的读者数量</span><br><span class="line">Semaphore r_mutex=1;</span><br><span class="line">Reader_i&#123;</span><br><span class="line"> while(1)&#123;</span><br><span class="line"> 	P(r_mutex);</span><br><span class="line"> 	reader_count++;</span><br><span class="line">	if(reader_count==1)&#123;</span><br><span class="line">		P(rw);</span><br><span class="line">	&#125;</span><br><span class="line">	V(r_mutex);</span><br><span class="line">	Read file;</span><br><span class="line">	P(r_mutex);</span><br><span class="line">	reader_count--;</span><br><span class="line">	if(reader_count==0)&#123;</span><br><span class="line">		V(rw);</span><br><span class="line">	&#125;</span><br><span class="line">	V(r_mutex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer_i&#123;</span><br><span class="line">	P(rw);</span><br><span class="line">	Write file;</span><br><span class="line">	V(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><ul>
<li>有一个睡觉的理发师等待顾客唤醒理发</li>
<li>当顾客发现理发师在为其他顾客理发时就坐到椅子上等待</li>
<li>当椅子上都坐满了（椅子的最大值为MAX_CHAIRS），前来理发的新顾客离开</li>
</ul>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Semaphore customer=0;//理发师正在理发的顾客</span><br><span class="line">Semaphore barber=1;//理发师目前是否可以理发</span><br><span class="line">Semaphore mutex=1;//互斥信号量</span><br><span class="line">int waiting=0;等待的顾客数量</span><br><span class="line"></span><br><span class="line">Barber&#123;</span><br><span class="line">	P(customer);</span><br><span class="line">	P(mutex);</span><br><span class="line">	waiting--;</span><br><span class="line">	V(mutex);</span><br><span class="line">	cut hair;</span><br><span class="line">	V(barber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer_i&#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	if(waiting&lt;MAX_CHAIRS)&#123;</span><br><span class="line">		waiting++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		P(barber);</span><br><span class="line">		V(customer);</span><br><span class="line">		get haircut;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		V(mutex);</span><br><span class="line">		leaving;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[5]=&#123;1&#125;;</span><br><span class="line"></span><br><span class="line">Philosopher_i&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		Thinking;</span><br><span class="line">		P(chopstick[i]);</span><br><span class="line">		P(chopstick[(i+1)%5]);</span><br><span class="line">		Eating;</span><br><span class="line">		V(chopstick[i]);</span><br><span class="line">		V(chopstick[(i+1)%5]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="哲学家用餐死锁问题"><a href="#哲学家用餐死锁问题" class="headerlink" title="哲学家用餐死锁问题"></a>哲学家用餐死锁问题</h4><ul>
<li>当所有人同时拿到一侧的筷子时，发生永远等待现象（即死锁）</li>
<li>有若种办法可避免死锁：<ul>
<li>至多允许四个哲学家同时吃；</li>
<li>奇数号先取左手边的筷子，偶数号先取右手边的筷子；</li>
<li>每个哲学家取到手边的两根筷子才吃，否则一根也不取。</li>
</ul>
</li>
<li>进程访问资源流程：申请-&gt;使用-&gt;释放</li>
</ul>
<h4 id="DEADLOCK-定义"><a href="#DEADLOCK-定义" class="headerlink" title="DEADLOCK(定义)"></a>DEADLOCK(定义)</h4><ul>
<li>In a multiprogramming environment,several processes may compete for a finite（有限的） number of resources.</li>
<li>A process requests resources;if the resources are <strong>not available</strong> at that time,the process enters a <strong>waiting state</strong>.</li>
<li>Sometimes,a waiting process is never again able to change state,because the resources it has requested are held（占有） by other waiting processes.</li>
<li>This situation is called a <strong>deadlock</strong>.</li>
</ul>
<h4 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h4><ul>
<li><p>饥饿：进程长时间等待</p>
<p>e.g.低优先级进程总是等待高优先级所占有的进程</p>
</li>
<li><p>死锁：循环等待资源</p>
<ul>
<li>A和B分别占有打印机和扫描仪</li>
<li>同时分别申请扫描仪和打印机</li>
</ul>
</li>
<li><p>死锁&#x3D;&gt;饥饿（反之不亦然）</p>
<ul>
<li>饥饿可能终止</li>
<li>如果无外部干涉，死锁无法终止</li>
</ul>
</li>
</ul>
<h4 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h4><p>死锁发生，以下四个条件同时成立</p>
<ul>
<li><p>互斥使用</p>
<p>一个时刻，一个资源仅能被一个进程占有</p>
</li>
<li><p>不可剥夺</p>
<p>除了资源占有进程主动释放资源，其它进程都不可抢夺其资源</p>
</li>
<li><p>占有和等待</p>
<p>一个进程请求资源得不到满足等待时，不释放已占有资源</p>
</li>
<li><p>循环等待（上面三个条件同时存在产生的结果）</p>
<p>每一个进程分别等待它前一个进程所占有的资源</p>
</li>
</ul>
<h4 id="METHONDS-FOR-HANDLING-DEADLOCKS"><a href="#METHONDS-FOR-HANDLING-DEADLOCKS" class="headerlink" title="METHONDS FOR HANDLING DEADLOCKS"></a>METHONDS FOR HANDLING DEADLOCKS</h4><ul>
<li>Deadlocks are NOT allowed to appear.We must <strong>prevent</strong> or <strong>avoid</strong> deadlock state.</li>
<li>Deadlocks are allowed to appear,but the system can <strong>detect</strong>（检测） them and <strong>recover</strong>.</li>
<li>We <strong>pretend</strong> that deadlocks never occur in the system.</li>
</ul>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><h5 id="死锁的防止-Prevention"><a href="#死锁的防止-Prevention" class="headerlink" title="死锁的防止(Prevention)"></a>死锁的防止(Prevention)</h5><p>破外四个必要条件之一</p>
<h5 id="死锁的避免-Avoidance"><a href="#死锁的避免-Avoidance" class="headerlink" title="死锁的避免(Avoidance)"></a>死锁的避免(Avoidance)</h5><p>允许四个必要条件同时存在，在并发进程中做出妥善安排避免死锁的发生</p>
<h5 id="死锁的检测和恢复（Detection-amp-Recovery）"><a href="#死锁的检测和恢复（Detection-amp-Recovery）" class="headerlink" title="死锁的检测和恢复（Detection&amp;Recovery）"></a>死锁的检测和恢复（Detection&amp;Recovery）</h5><p>允许死锁的发生，系统及时地检测死锁并解除它</p>
<h4 id="死锁的防止"><a href="#死锁的防止" class="headerlink" title="死锁的防止"></a>死锁的防止</h4><p>破坏死锁任一必要条件（可操作性太复杂）</p>
<ul>
<li><p>互斥使用&#x3D;&gt;允许资源共享使用</p>
<p>不可行</p>
</li>
<li><p>不可剥夺&#x3D;&gt;资源可被抢夺</p>
<p>不可行</p>
</li>
<li><p>占有和等待</p>
<p>可行</p>
<p>缺点：资源浪费</p>
</li>
<li><p>循环等待</p>
<p>可行</p>
<p>缺点：资源浪费</p>
</li>
</ul>
<h4 id="安全状态-SAFE-STATE"><a href="#安全状态-SAFE-STATE" class="headerlink" title="安全状态(SAFE STATE)"></a>安全状态(SAFE STATE)</h4><ul>
<li><strong>A state is safe</strong> if the system can allocate resources to each process (up to its maximum)in some order and still avoid a deadlock.More formally,a system is in a safe state only if there exists <strong>a safe sequence.</strong></li>
<li>If no such sequence exists,then the system state is said to be unsafe.</li>
<li>A safe state is NOT a deadlocked state.</li>
<li>An unsafe state MAY lead to a deadlock.</li>
</ul>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><ul>
<li>系统对进程的每一次资源申请都进行详细的计算，根据结果决定是分配资源还是让其等待，确保系统始终处于安全状态，避免死锁的发生。</li>
<li>银行家算法（Banker’s algorithm)<ul>
<li>已知系统中所有资源的种类和数量</li>
<li>已知进程所需要的各类资源最大需求量</li>
<li>该算法可以计算出当前的系统状态是否安全（寻找安全序列)</li>
</ul>
</li>
</ul>
<h4 id="银行家算法-数据结构"><a href="#银行家算法-数据结构" class="headerlink" title="银行家算法-数据结构"></a>银行家算法-数据结构</h4><ul>
<li>Available:当前系统中可用资源数量</li>
<li>Max:每个进程的最大资源需求量</li>
<li>Allocation:已经分配给进程的资源数量</li>
<li>Need:每个进程还需要的资源数量</li>
</ul>
<h4 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h4><ul>
<li>优点：允许死锁必要条件同时存在</li>
<li>缺点：缺乏实用价值<ul>
<li>进程运行前就要求知道其所需资源的最大数量</li>
<li>要求进程是无关的，若考虑同步情况，可能会打乱安全序列</li>
<li>要求进入系统的进程个数和资源数固定</li>
</ul>
</li>
</ul>
<h4 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h4><ul>
<li>允许死锁发生，操作系统不断监视系统进展情况判断死锁是否发生</li>
<li>一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行</li>
<li>死锁检测的时机<ul>
<li>当进程等待时检测死锁（系统开销大）</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
</ul>
<h4 id="资源分配图表示法"><a href="#资源分配图表示法" class="headerlink" title="资源分配图表示法"></a>资源分配图表示法</h4><ul>
<li>资源类（资源的不同类型）</li>
<li>资源实例（存在于每个资源中）</li>
<li>进程</li>
<li>申请边</li>
<li>分配边</li>
</ul>
<h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><ul>
<li>如果能在“资源分配图”中消去某进程的所有请求边和分配边，则称该进程为<strong>孤立结点</strong>。<ul>
<li>可完全简化</li>
<li>不可完全简化</li>
</ul>
</li>
<li>系统为死锁状态的充分条件是：当且仅当该状态的进程一资源分配图”是不可完全简化的。该充分条件称为<strong>死锁定理</strong></li>
</ul>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><ul>
<li><p>中止进程，强制回收资源</p>
<ul>
<li>交通问题：将某列火车吊起来</li>
<li>哲学家问题：将某个哲学家射死</li>
</ul>
</li>
<li><p>剥夺资源，但不中止进程</p>
</li>
<li><p>进程回退(roll back)</p>
<ul>
<li>就像DVD的回退，好像最近一段时间什么都没有发生过</li>
<li>交通问题：让某列火车倒车</li>
<li>哲学家问题：让某个哲学家放下一把叉子</li>
</ul>
</li>
<li><p>重新启动</p>
<p>没有办法的办法，但却是一个肯定有效的办法</p>
</li>
</ul>
<h4 id="HOW-OS-DO-TO-DEADLOCKS"><a href="#HOW-OS-DO-TO-DEADLOCKS" class="headerlink" title="HOW OS DO TO DEADLOCKS?"></a>HOW OS DO TO DEADLOCKS?</h4><ul>
<li>In the absence of algorithms to detect and recover from deadlocks,we may arrive at a situation in which the system is in a deadlocked state yet has no way of recognizing what has happened.In this case,the undetected deadlock will cause the system’s performance（执行效率） to deteriorate（恶化）,because resources are being held by processes that cannot run and because more and more processes,as they make requests for resources,will enter a deadlocked state.Eventually,the system will stop functioning and will need to be restarted manually（手动重启）</li>
<li>Although this method may not seem to be a viable（可行） approach to the deadlock problem,it is nevertheless used in most<br>operating systems.</li>
</ul>
<h3 id="进程内存空间"><a href="#进程内存空间" class="headerlink" title="进程内存空间"></a>进程内存空间</h3><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>内存单元看到的地址，是指令和数据真实的内存地址，而逻辑地址是面向程序而言的</p>
<p>**物理地址&#x3D;基址+逻辑地址 **</p>
<h4 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h4><p>以32位机器为例，地址总线是32位，可寻址的最大内存空间是22 Bytes,即4 GBytes。每一个运行的进程都可以获得一个4GB的逻辑地址空间，这个空间被分成两个部分：内核空间和用户空间，其中用户空间分配到从0x00000000到0xC0000000共3GB的地址，而内核空间分配了0xC0000000到0 xFFFFFFFF高位的1GB地址</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="MAIN-MEMORY（主存）"><a href="#MAIN-MEMORY（主存）" class="headerlink" title="MAIN MEMORY（主存）"></a>MAIN MEMORY（主存）</h4><ul>
<li><strong>Main memory</strong> is central to the operation of a modern computer system.</li>
<li>Memory consists of a large <strong>array of bytes（字节数组或者字节序列）,each with its own address.</strong></li>
<li>The CPU fetches instructions from memory according to the value of <strong>the program counter(PC)</strong>.These instructions may cause additional loading from and storing to specific memory addresses.</li>
<li>A typical <strong>instruction-execution cycle</strong>（指令执行周期）,for example,first <strong>fetches</strong>（取指） an instruction from memory.The instruction is then <strong>decoded</strong>（译码） and may cause operands to be fetched from memory.After the instruction has been <strong>executed</strong> on the operands,results may be stored back in memory.</li>
</ul>
<h4 id="高速缓存CACHE"><a href="#高速缓存CACHE" class="headerlink" title="高速缓存CACHE"></a>高速缓存CACHE</h4><p>高速缓存是一种存取速度比内存快，但容量比内存小的多的存储器，它可以加快访问物理内存的相对速度。</p>
<h4 id="保护操作系统和用户进程"><a href="#保护操作系统和用户进程" class="headerlink" title="保护操作系统和用户进程"></a>保护操作系统和用户进程</h4><p>用户进程不可以访问操作系统内存数据，以及用户进程空间之间不能互相影响</p>
<ul>
<li>通过硬件实现，因为操作系统一般不干预CPU对内存的访问<ul>
<li>base register:基址寄存器</li>
<li>limit register:限长寄存器</li>
</ul>
</li>
<li>上述两个寄存器的值只能被操作系统的<strong>特权指令</strong>加载</li>
</ul>
<h4 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h4><ul>
<li>存取速度</li>
<li>操作正确（分配和回收）</li>
<li>保护操作系统</li>
<li>保护用户进程</li>
<li>地址转换</li>
</ul>
<h4 id="地址空间和地址转换"><a href="#地址空间和地址转换" class="headerlink" title="地址空间和地址转换"></a>地址空间和地址转换</h4><ul>
<li><strong>逻辑地址</strong>：面向程序的地址，总是从0开始编址，每一条指令的逻辑地址就是与第1条指令之间的相对偏移，因此逻辑地址也叫<strong>相对地址</strong>或<strong>虚拟地址</strong>。</li>
<li><strong>物理地址</strong>：内存单元看到的实际地址，也称为绝对地址。</li>
<li>所有逻辑地址的集合称为<strong>逻辑地址空间</strong>，这些逻辑地址对应的所有物理地址集合称为<strong>物理地址空间</strong>。</li>
<li><strong>地址转换</strong>：由逻辑地址转换成物理地址。</li>
</ul>
<h4 id="地址转换时机"><a href="#地址转换时机" class="headerlink" title="地址转换时机"></a>地址转换时机</h4><h5 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h5><p>前提：提前知道这个程序要加载的物理内存的起始地址R</p>
<p>缺点：不允许被移动</p>
<h5 id="加载时"><a href="#加载时" class="headerlink" title="加载时"></a>加载时</h5><p>加载时知道基址R</p>
<p>缺点：不允许被移动</p>
<h5 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h5><p>逻辑地址-&gt;MMU-&gt;物理地址</p>
<h4 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h4><p>Memory-Management Unit完成逻辑地址到物理地址<strong>运行时</strong>的转换工作。</p>
<ul>
<li>重定位寄存器(relocation register)或基址寄存器（base register）</li>
</ul>
<h4 id="CONTIGUOUS-MEMORY-ALLOCATION（连续内存分配）"><a href="#CONTIGUOUS-MEMORY-ALLOCATION（连续内存分配）" class="headerlink" title="CONTIGUOUS MEMORY ALLOCATION（连续内存分配）"></a>CONTIGUOUS MEMORY ALLOCATION（连续内存分配）</h4><p>In contiguous memory allocation,each process is contained in a single section of memory that is contiguous to the section containing the next process.</p>
<ul>
<li>Memory allocation</li>
<li>Memory recycle</li>
<li>Memory protection</li>
</ul>
<h4 id="FIXED-SIZED-PARTITION（固定大小分区）"><a href="#FIXED-SIZED-PARTITION（固定大小分区）" class="headerlink" title="FIXED-SIZED PARTITION（固定大小分区）"></a>FIXED-SIZED PARTITION（固定大小分区）</h4><p>Memory is divided to several fixed-sized partitions. Each partition may contain exactly one process.</p>
<ul>
<li>缺点：存在碎片造成空间浪费</li>
</ul>
<h4 id="VARIABLE-PARTITION（可变分区）"><a href="#VARIABLE-PARTITION（可变分区）" class="headerlink" title="VARIABLE-PARTITION（可变分区）"></a>VARIABLE-PARTITION（可变分区）</h4><ul>
<li>In the variable-partition scheme,the operating system keeps two tables indicating which parts of memory are available and which are occupied.</li>
<li><strong>Initially</strong>,all memory is available for user processes and is considered one large block of available memory,<strong>a hole</strong>.（孔&#x2F;洞）</li>
<li><strong>Eventually</strong>,as you will see,memory contains a set of holes of various sizes.（不同大小孔洞的集合）</li>
</ul>
<h4 id="动态存储分配问题"><a href="#动态存储分配问题" class="headerlink" title="动态存储分配问题"></a>动态存储分配问题</h4><ul>
<li><p>首次适应</p>
<p>分配首个足够大的孔，效率最高</p>
</li>
<li><p>最佳适应</p>
<p>分配最小的足够大的孔，浪费最小</p>
</li>
<li><p>最坏适应</p>
<p>分配最大的孔，产生的剩余孔更可能被再利用</p>
</li>
</ul>
<h4 id="地址转换和保护"><a href="#地址转换和保护" class="headerlink" title="地址转换和保护"></a>地址转换和保护</h4><ul>
<li><p>两种连续分配方案的地址转换方式是相似的：</p>
<p>**物理地址&#x3D;基址+逻辑地址 **</p>
</li>
<li><p>地址保护策略：与限长limit进行比较</p>
</li>
</ul>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>Fragmentation:some little pieces of memory hardly to be used.</p>
<ul>
<li>internal fragmentation（对于固定分区而言）</li>
<li>external fragmentation（对于可变分区而言）<ul>
<li>解决办法：compaction（紧凑&#x2F;压缩）</li>
<li>限制<ul>
<li>static relocation（静态地址转化不可以使用，运行时地址转换才能使用）</li>
<li>cost（开销）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h3><h4 id="MOTIVATION"><a href="#MOTIVATION" class="headerlink" title="MOTIVATION"></a>MOTIVATION</h4><ul>
<li>Solution to fragmentation（碎片）:permit the logical address space of processes to be noncontiguous.（不连续)</li>
<li>The view of memory is different between<ul>
<li>logical (programmer’s ):a variable-sized segments(可变大小的段)</li>
<li>physical:a linear array of bytes（线性数组&#x2F;字节序列）</li>
</ul>
</li>
<li>The hardware could provide a memory mechanism that mapped the logical view to the actual physical memory.</li>
</ul>
<h4 id="程序员眼中的内存世界"><a href="#程序员眼中的内存世界" class="headerlink" title="程序员眼中的内存世界"></a>程序员眼中的内存世界</h4><ul>
<li>程序员看到的<ul>
<li>主函数和一组其他函数</li>
<li>各种数据结构：变量、结构体、对象、数组等</li>
<li>所有的模块都是名字来引用的</li>
</ul>
</li>
<li>因此他们认为在内存中，程序是由若干个大小不等的段构成的，每个段都有专门的用途，段的大小和用途相关。</li>
<li><strong>段和段之间不必连续存放（离散）</strong></li>
</ul>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>逻辑地址：段号+段内位移</p>
<ul>
<li>段基址</li>
<li>段限长</li>
<li>段表</li>
</ul>
<p>转换成物理地址</p>
<ul>
<li>段内位移小于段限长，物理地址&#x3D;段基址+段内位移</li>
<li>段内位移大于段限长，error</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>逻辑地址：页号+页内位移</p>
<p>物理地址&#x3D;页框号×页面大小+页内位移</p>
<p>若以二进制表示，物理地址：页框号+页内位移</p>
<h4 id="LOGICAL-ADDRESS（分页的逻辑地址）"><a href="#LOGICAL-ADDRESS（分页的逻辑地址）" class="headerlink" title="LOGICAL ADDRESS（分页的逻辑地址）"></a>LOGICAL ADDRESS（分页的逻辑地址）</h4><ul>
<li>The <strong>page size</strong>(like the <strong>frame size</strong>)is defined by the hardware.The size of a page is a power of 2,varying between 512 bytes and 1 GB per page,depending on the computer architecture.</li>
<li>The selection of a power of 2 as a page size makes the translation of a logical address into a page number and page offset <strong>particularly easy</strong>.</li>
<li>If the size of the <strong>logical address space is 2^m</strong>,and a <strong>page size is 2^n bytes</strong>, then the high-order m-n bits of a logical address designate the <strong>page number</strong>,and the n low-order bits designate the <strong>page offset</strong>.Thus,the logical address is as follows:</li>
</ul>
<h4 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h4><table>
<thead>
<tr>
<th>分段</th>
<th>分页</th>
</tr>
</thead>
<tbody><tr>
<td>信息的逻辑单位</td>
<td>信息的物理单位</td>
</tr>
<tr>
<td>段长是任意的</td>
<td>页长由系统确定</td>
</tr>
<tr>
<td>段的起始地址可以从主存任一地址开始</td>
<td>页框起始地址只能以页框大小的整数倍开始</td>
</tr>
<tr>
<td>(段号，段内位移)构成了二维地址空间</td>
<td>(页号，页内位移)构成了一维地址空间</td>
</tr>
<tr>
<td>会产生外部碎片</td>
<td>消除了外部碎片，但会出现内部碎片</td>
</tr>
</tbody></table>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><h4 id="PAGE-TABLE"><a href="#PAGE-TABLE" class="headerlink" title="PAGE TABLE"></a>PAGE TABLE</h4><ul>
<li>The operating system maintains a copy of the <strong>page table</strong> for <strong>each process</strong>.</li>
<li>This copy is used to <strong>translate logical addresses to physical addresses</strong>.</li>
<li>It is also used by the CPU dispatcher（调度程序） to define the <strong>hardware page table</strong> when a process is to be allocated the CPU.</li>
<li>Paging therefore <strong>increases the context-switch time</strong>.（上下文切换开销）</li>
</ul>
<h4 id="HARDWARE-PAGE-TABLE"><a href="#HARDWARE-PAGE-TABLE" class="headerlink" title="HARDWARE PAGE TABLE"></a>HARDWARE PAGE TABLE</h4><ul>
<li><strong>The page table</strong> is <strong>kept in main memory</strong> and <strong>a page</strong> **table base register(PTBR) **（CPU中的寄存器）points to the page table.</li>
<li>Changing page tables requires changing only this one register,substantially reducing context-switch time.</li>
<li>With this scheme,<strong>two memory accesses</strong>（访问内存两次） are needed to access a byte (one for the page-table entry,one for the byte).</li>
</ul>
<h4 id="TLB（是一个硬件）"><a href="#TLB（是一个硬件）" class="headerlink" title="TLB（是一个硬件）"></a>TLB（是一个硬件）</h4><p>**TLB(Translation Look-aside Buffer) **（转换旁路&#x2F;后备缓冲区&#x2F;相联存储器）is a kind of small, fast-lookup hardware <strong>cache</strong>.It is used with page tables in the following way.</p>
<ul>
<li>The TLB contains **only a few of the page-table entries.**（仅包含部分的页表的页表项，就是快表）</li>
<li>When a logical address is generated by the CPU,its page number is presented to the TLB.</li>
<li><strong>If the page number is found</strong>,its frame number is <strong>immediately</strong> available and is used to access memory.（一次内存访问）</li>
<li>If <strong>TLB miss</strong>（未命中）,a memory reference to the page table must be made.（两次内存访问）</li>
</ul>
<h4 id="TLB-HIT-RATIO（命中率）"><a href="#TLB-HIT-RATIO（命中率）" class="headerlink" title="TLB HIT RATIO（命中率）"></a>TLB HIT RATIO（命中率）</h4><ul>
<li>The percentage of times（次数的比例） that the page number of interest is found in the TLB is called the <strong>hit ratio</strong>.</li>
<li>An <strong>80-percent hit ratio</strong>,for example,means that we find the desired page number in the TLB 80 percent of the time.If it takes <strong>100 nanoseconds</strong> to access memory,please find the <strong>effective memory-access time.</strong><ul>
<li>effective access time &#x3D; 0.80 x 100 + 0.20 x  200 &#x3D; 120 ns</li>
</ul>
</li>
</ul>
<h4 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h4><ul>
<li>为了防止地址转换时出现异常，可在页表每个条目设置一个“<strong>valid–invalid</strong>”比特位，用于表示该页的有效性。</li>
<li>这个方法可以被轻松扩展以提供更好的保护级别，如“只读”、“读写”、“可执行”等。</li>
</ul>
<h4 id="页表页"><a href="#页表页" class="headerlink" title="页表页"></a>页表页</h4><p>逻辑地址：页表页号+页号+页内位移</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><ul>
<li>上面是一个32位地址采用<strong>两级页表</strong>的例子，页面大小是4 KBytes,第一级页表页的数量是1K个，每个页表页中包含的页面数量也是1K个。</li>
<li>下面是x86-64架构CPU采用的<strong>四级页表</strong>方案</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><ul>
<li><p>时间局部性(Temporal locality)</p>
<p>如果某个信息这次被访问，那它有可能在不久的未来被多次访问，</p>
</li>
<li><p>空间局部性(Spatial locality)</p>
<p>如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到，</p>
</li>
<li><p>内存局部性(Memory locality)</p>
<p>访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是空间局部性在内存上的体现</p>
</li>
<li><p>分支局部性(Branch locality)</p>
<p>计算机中大部分指令是顺序执行，顺序执行和非顺序执行的比例大致是5：1</p>
</li>
<li><p>等距局部性(Equidistant locality)</p>
<p>等距局部性是指如果某个位置被访问，那和它相邻等距离的连续地址极有可<br>能会被访问到。</p>
</li>
</ul>
<h4 id="修改缓存数据"><a href="#修改缓存数据" class="headerlink" title="修改缓存数据"></a>修改缓存数据</h4><ul>
<li><p>Write through（直接写）</p>
<p>修改缓存数据的同时修改内存数据</p>
</li>
<li><p>Write back（回写）</p>
<p>只修改缓存数据，直到该数据要被清除出缓存再修改内存中的数据</p>
</li>
</ul>
<h4 id="缓存数据的淘汰"><a href="#缓存数据的淘汰" class="headerlink" title="缓存数据的淘汰"></a>缓存数据的淘汰</h4><ul>
<li>缓存的容量很小，当缓存满的时候，就需要将缓存中的部分数据淘汰，装入新的数据。</li>
<li>淘汰<ul>
<li>用得最少的</li>
<li>FIFO</li>
</ul>
</li>
</ul>
<h4 id="部分装入和部分对换"><a href="#部分装入和部分对换" class="headerlink" title="部分装入和部分对换"></a>部分装入和部分对换</h4><ul>
<li>部分装入<ul>
<li>进程运行时仅加戟部分进入内存，而不必全部装入</li>
<li>其余部分暂时放在swap space</li>
</ul>
</li>
<li>部分对换<ul>
<li>可以将进程部分对换出内存，用以腾出内存空间</li>
<li>对换出的部分暂时放在swap space</li>
</ul>
</li>
</ul>
<h4 id="VIRTUAL-MEMORY（虚拟内存）"><a href="#VIRTUAL-MEMORY（虚拟内存）" class="headerlink" title="VIRTUAL MEMORY（虚拟内存）"></a>VIRTUAL MEMORY（虚拟内存）</h4><ul>
<li><strong>Virtual memory</strong> is a technique that allows the execution of processes that are not completely in memory.（部分装入）</li>
<li>One major advantage of this scheme is that programs can be <strong>larger than physical memory.</strong></li>
<li>Further,virtual memory abstracts main memory into an extremely large,uniform array of storage,<strong>separating logical memory</strong> as viewed by the user <strong>from physical memory.</strong></li>
<li>This technique frees programmers from the concerns of memory-storage limitations.</li>
</ul>
<h4 id="DEMAND-PAGING（请求调页）"><a href="#DEMAND-PAGING（请求调页）" class="headerlink" title="DEMAND PAGING（请求调页）"></a>DEMAND PAGING（请求调页）</h4><ol>
<li>基于分页方案</li>
<li>页表：valid&#x2F;invalid</li>
<li>内存驻留</li>
<li>demand a page</li>
<li>paging</li>
</ol>
<ul>
<li>With demand-paged virtual memory,pages are loaded only when they are demanded during program execution.</li>
<li>Pages that are never accessed are thus never loaded into physical<br>memory.</li>
</ul>
<h4 id="请求调页步骤"><a href="#请求调页步骤" class="headerlink" title="请求调页步骤"></a>请求调页步骤</h4><ol>
<li>reference（引用）</li>
<li>trap：page fault（缺页中断）</li>
<li>接下来操作系统调页</li>
<li>page is on backing store（找页面）</li>
<li>bring in missing page（将缺失页面加载到内存当中）</li>
<li>reset page table（更新页表)</li>
<li>restart instruction</li>
</ol>
<h4 id="请求调页的性能"><a href="#请求调页的性能" class="headerlink" title="请求调页的性能"></a>请求调页的性能</h4><ul>
<li>假设访问内存时间为ma,处理一次缺页中断的时间记作page fault time,令p为缺页中断的出现几率，则有效访问时间的计算公式为：<ul>
<li>effective access time &#x3D;(1-p) x ma + p x page fault time</li>
</ul>
</li>
<li>若ma&#x3D;200ns,page fault time&#x3D;8ms，P&#x3D;0.001,则<ul>
<li>effective access time &#x3D;8200ms</li>
</ul>
</li>
<li><strong>缺页中断率p对性能影响重大</strong></li>
</ul>
<h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><p>当进程在执行过程中发生了缺页，在请求调页的时候发现内存已经没有空闲页框可用，操作系统在此时会做出一个处理：<strong>页面置换</strong>。</p>
<h4 id="页面置换策略"><a href="#页面置换策略" class="headerlink" title="页面置换策略"></a>页面置换策略</h4><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><p>总是淘汰最先进入内存的页面，因为它在内存中待的时间最久。</p>
<h5 id="OPTIMAL（最优）"><a href="#OPTIMAL（最优）" class="headerlink" title="OPTIMAL（最优）"></a>OPTIMAL（最优）</h5><p>总是淘汰最长时间不会再使用的页面。</p>
<ul>
<li>无法实现，因为无法预测未来</li>
</ul>
<h4 id="LRU-LEAST-RECENT-UNUSED）"><a href="#LRU-LEAST-RECENT-UNUSED）" class="headerlink" title="LRU (LEAST RECENT UNUSED）"></a>LRU (LEAST RECENT UNUSED）</h4><p>总是淘汰最近最少使用的页面。</p>
<h4 id="THRASHING（抖动）"><a href="#THRASHING（抖动）" class="headerlink" title="THRASHING（抖动）"></a>THRASHING（抖动）</h4><ul>
<li>If the process does not have the number of frames it needs to support pages in active use,it will quickly page-fault.At this point,it must replace some page.However, since all its pages are in active use,it must replace a page that will be needed again right away.Consequently,it quickly faults again,and again,and again,replacing pages that it must bring back in immediately</li>
<li>This high paging activity is called <strong>thrashing</strong>.<strong>A process is thrashing if it is spending more time paging than executing.</strong></li>
</ul>
<h4 id="抖动的原因"><a href="#抖动的原因" class="headerlink" title="抖动的原因"></a>抖动的原因</h4><ul>
<li>并发进程数量过多</li>
<li>进程页框分配不合理</li>
</ul>
<h4 id="PAGE-FAULT-FREQUENCY"><a href="#PAGE-FAULT-FREQUENCY" class="headerlink" title="PAGE FAULT FREQUENCY"></a>PAGE FAULT FREQUENCY</h4><p>PF称作<strong>页面故障（频）率</strong>，基于这个数据可以实施一个防止抖动的策略：动态调节分配给进程的页框数量。</p>
<h4 id="CONCLUDING-REMARKS"><a href="#CONCLUDING-REMARKS" class="headerlink" title="CONCLUDING REMARKS"></a>CONCLUDING REMARKS</h4><ul>
<li>Practically speaking,thrashing and the resulting swapping have a disagreeably large impact on performance.</li>
<li>The current best practice in implementing a computer facility is to include enough physical memory,whenever possible,to avoid thrashing and swapping.</li>
<li>From smartphones through mainframes,providing enough memory to keep all working sets in memory concurrently,except under extreme conditions,gives the best user experience.</li>
</ul>
<h3 id="大容量存储"><a href="#大容量存储" class="headerlink" title="大容量存储"></a>大容量存储</h3><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><ul>
<li><p>磁道（track）：能被磁头访问的一组同心圆</p>
</li>
<li><p>扇区（sector）：磁道上的区域，数据存放的基本单位</p>
</li>
<li><p>柱面：所有盘片同一磁头下的磁道集合</p>
</li>
<li><p>恒角速度CAV</p>
<ul>
<li><p>每条磁道上的肩区数相等</p>
</li>
<li><p>不同磁道密度不同，但转速恒定</p>
</li>
<li><p>硬盘</p>
</li>
</ul>
</li>
<li><p>恒线速度CLV</p>
<ul>
<li><p>每条磁道上的数据密度相等</p>
</li>
<li><p>磁道密度相同，但转速不断变化</p>
</li>
<li><p>读一个扇区的情况下，数据在外转速慢，在内转速快</p>
</li>
<li><p>DVD&#x2F;CD</p>
</li>
</ul>
</li>
</ul>
<h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><ul>
<li>低级格式化（Low-level formatting）<ul>
<li>Physical formatting</li>
<li>为每个扇区使用特殊的数据结构进行填充，包括一个头部、数据区域和一个尾部。</li>
<li>头部和尾部包含一些控制信息，如扇区号、ECC码等。</li>
</ul>
</li>
<li>高级格式化(High-level formatting)<ul>
<li>Logical formatting</li>
<li>构建文件系统，在磁盘上初始化文件系统数据结构，如空闲和已分配空间表、一个空目录等。</li>
</ul>
</li>
</ul>
<h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><ul>
<li>查找一个物理块的顺序：柱面号、磁头号和扇区号<ul>
<li>寻道时间Ts:将磁头定位到正确磁道（柱面）上所花的时间，与盘片直径和传动臂速度相关，平均20ms</li>
<li>旋转延迟T:所查找的扇区转到磁头下所用的时间，与磁盘的旋转速度有关，一个10,000r&#x2F;m的磁盘平均旋转延迟为3ms。</li>
<li>传送时间T:传送扇区内的数据的时间，同样取决于磁盘的旋转速度，T&#x3D;b&#x2F;(rN)(b为要传送的字节数，N为一个磁道中的字节数，r为转速)</li>
</ul>
</li>
<li>总的平均存取时间Ta&#x3D;Ts+Tr+T</li>
</ul>
<h4 id="DISK-I-x2F-O-REQUEST"><a href="#DISK-I-x2F-O-REQUEST" class="headerlink" title="DISK I&#x2F;O REQUEST"></a>DISK I&#x2F;O REQUEST</h4><p>Whenever a process needs I&#x2F;O to or from the disk,it issues a system call to the operating system.The request specifies several pieces of information:</p>
<ul>
<li>Whether this operation is input or output </li>
<li>What the disk address for the transfer is（柱面、磁头、扇区）</li>
<li>What the memory address for the transfer is</li>
<li>What the number of sectors（扇区） to be transferred is</li>
</ul>
<h4 id="DISK-SCHEDULING（磁盘调度）"><a href="#DISK-SCHEDULING（磁盘调度）" class="headerlink" title="DISK SCHEDULING（磁盘调度）"></a>DISK SCHEDULING（磁盘调度）</h4><p>For a multiprogramming system with many processes the disk queue may often have several pending requests.Thus,when one request is completed,the operating system chooses which pending request to service next.How does the operating system make this choice?</p>
<h5 id="FCFS-SCHEDULING"><a href="#FCFS-SCHEDULING" class="headerlink" title="FCFS SCHEDULING"></a>FCFS SCHEDULING</h5><h5 id="SSTF-SCHEDULING（Shortest-Seek-Time-First-最短寻道时间优先"><a href="#SSTF-SCHEDULING（Shortest-Seek-Time-First-最短寻道时间优先" class="headerlink" title="SSTF SCHEDULING（Shortest-Seek-Time First 最短寻道时间优先)"></a>SSTF SCHEDULING（Shortest-Seek-Time First 最短寻道时间优先)</h5><ul>
<li>”磁臂粘连“现象-&gt;饥饿</li>
</ul>
<h5 id="SCAN-SCHEDULING（扫描算法）"><a href="#SCAN-SCHEDULING（扫描算法）" class="headerlink" title="SCAN SCHEDULING（扫描算法）"></a>SCAN SCHEDULING（扫描算法）</h5><ul>
<li>负载均衡</li>
</ul>
<h5 id="C-SCAN-SCHEDULING（循环扫描算法）"><a href="#C-SCAN-SCHEDULING（循环扫描算法）" class="headerlink" title="C-SCAN SCHEDULING（循环扫描算法）"></a>C-SCAN SCHEDULING（循环扫描算法）</h5><h5 id="LOOK-SCHEDULING（电梯算法）"><a href="#LOOK-SCHEDULING（电梯算法）" class="headerlink" title="LOOK SCHEDULING（电梯算法）"></a>LOOK SCHEDULING（电梯算法）</h5><h4 id="SELECTION-OF-A-ALGORITHM"><a href="#SELECTION-OF-A-ALGORITHM" class="headerlink" title="SELECTION OF A ALGORITHM"></a>SELECTION OF A ALGORITHM</h4><ul>
<li>FCFS is the simplest.</li>
<li>SSTF is common and has a natural appeal but it may cause a starvation problem.</li>
<li>SCAN and C-SCAN perform better for systems that place a heavy load on the disk.</li>
<li>How to know which algorithm is chosen by Linux?</li>
</ul>
<h4 id="LINUX-IO-SCHEDULER"><a href="#LINUX-IO-SCHEDULER" class="headerlink" title="LINUX IO SCHEDULER"></a>LINUX IO SCHEDULER</h4><ul>
<li>noop:it performs FCFS policy which is good enough for SSD.</li>
<li>deadline:it works by creating two queues:a read queue and a write queue.Each I&#x2F;O request has a time stamp(时间戳) associated that is used by the kernel for an expiration time.When an I&#x2F;O request reaches its deadline,it is pushed to the highest priority</li>
<li>cfq:Complete Fairness Queueing works by creating a per- process I&#x2F;O queue.（为每个进程维护一个队列）The goal of this I&#x2F;O scheduler is to provide a fair I&#x2F;O priority to each process.While the CFQ algorithm is complex,the gist of this scheduler is that after ordering the queues to reduce disk seeking,it services these per-process I&#x2F;O queues in a <strong>round-robin</strong> fashion.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h></h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://pigwzq.github.io/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://pigwzq.github.io/2023/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Wzq</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-10-28</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-11-26</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_4.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/10/git/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_2.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/09/23/2023-9-23-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304202108861.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wzq</div><div class="author-info__description">演示博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pigWzq"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/pigWzq/" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1766522495@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-xinwengonggao"></use></svg></a><span>公告栏</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-text">进程的描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-text">程序顺序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">程序顺序执行时的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-text">程序的并发执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">程序并发执行时的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%89%B9%E5%BE%81"><span class="toc-text">进程的定义及特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">进程的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E2%80%94-%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-text">进程的特征—-与程序的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E5%8F%8A%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">进程并发制约关系及临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-text">并发进程间制约关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">临界区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99"><span class="toc-text">进程同步机制基本准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">进程互斥访问临界资源的软件解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%951-%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E7%BC%96%E5%8F%B7"><span class="toc-text">进程互斥算法1-设置访问编号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%952-%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-text">进程互斥算法2-设置访问标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%953-%E8%AE%BE%E7%BD%AE%E6%AC%B2%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-text">进程互斥算法3-设置欲访问标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%954-%E7%BC%96%E5%8F%B7-%E6%A0%87%E5%BF%97%EF%BC%88Peterson%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">进程互斥算法4-编号+标志（Peterson算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">整型信号量机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">记录型信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">信号量类型声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%EF%BC%88s%EF%BC%89%E6%93%8D%E4%BD%9C%E6%8F%8F%E8%BF%B0"><span class="toc-text">wait（s）操作描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal%EF%BC%88s%EF%BC%89%E6%93%8D%E4%BD%9C%E6%8F%8F%E8%BF%B0"><span class="toc-text">signal（s）操作描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-text">AND型信号量集机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%AD%96"><span class="toc-text">对策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swait%EF%BC%88s1%EF%BC%8Cs2%EF%BC%8C%E2%80%A6%EF%BC%8Csn%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-text">Swait（s1，s2，…，sn）操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swait%E8%AF%A6%E7%BB%86"><span class="toc-text">Swait详细</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ssignal%EF%BC%88s1%EF%BC%8Cs2%EF%BC%8C%E2%80%A6%EF%BC%8Csn%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-text">Ssignal（s1，s2，…，sn）操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-text">一般信号量集机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-1"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swait%EF%BC%88s1%EF%BC%8Ct1%EF%BC%8Cd1%EF%BC%8C%E2%80%A6%EF%BC%8Csn%EF%BC%8Ctn%EF%BC%8Cdn%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-text">Swait（s1，t1，d1，…，sn，tn，dn）操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swait%E8%AF%A6%E7%BB%86-1"><span class="toc-text">Swait详细</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ssignal%EF%BC%88s1%EF%BC%8Cd1%EF%BC%8C%E2%80%A6%EF%BC%8Csn%EF%BC%8Cdn%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-text">Ssignal（s1，d1，…，sn，dn）操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">一般信号量集的几种特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Swait-s-d-d"><span class="toc-text">Swait(s,d,d)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Swait-s-1-1"><span class="toc-text">Swait(s,1,1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Swait-s-1-0"><span class="toc-text">Swait(s,1,0)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80"><span class="toc-text">基于信号量机制解决进程并发问题的应用基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E2%80%94-%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">利用信号量实现互斥—-主程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E2%80%94-%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">利用信号量实现互斥—-子程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90"><span class="toc-text">问题剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%BB%A1%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">空缓冲区和满缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">进程互斥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8F%98%E9%87%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">程序变量设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E8%A1%A8%E7%A4%BA%E6%9C%BA%E5%88%B6"><span class="toc-text">循环缓冲表示机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8C%87%E9%92%88in"><span class="toc-text">输入指针in</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%8C%87%E9%92%88out"><span class="toc-text">输出指针out</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%82%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-text">暂存数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">程序信号量的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%8A%E5%85%B6%E6%8C%87%E9%92%88%EF%BC%89%E7%9A%84%E4%BA%92%E6%96%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">循环缓冲（缓冲区及其指针）的互斥使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">资源信号量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">生产者子程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">消费者子程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%8F%8D%E6%80%9D"><span class="toc-text">初步解决方案的反思</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%9B%B8%E9%82%BBwait%EF%BC%88signal%EF%BC%89%E6%93%8D%E4%BD%9C%E9%A2%A0%E5%80%92%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text">关于相邻wait（signal）操作颠倒的分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Esignal%E6%93%8D%E4%BD%9C%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text">关于signal操作缺失的分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAND%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%94%9F%E4%BA%A7-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于AND信号量的生产&#x2F;消费者子程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">生产者子程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">消费者子程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A6%81%E9%A2%86"><span class="toc-text">同步问题程序设计要领</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZGS%E7%89%88"><span class="toc-text">ZGS版</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ZGS%E7%89%88"><span class="toc-text">生产者子程序设计ZGS版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1ZGS%E7%89%88"><span class="toc-text">消费者子程序设计ZGS版</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="toc-text">哲学家进餐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-text">问题解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AD%B7%E9%BD%90%E4%B8%BE-AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">双筷齐举[AND型信号量]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">子程序设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AD%B7%E9%BD%90%E4%B8%BE-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">双筷齐举[记录型信号量]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">子程序设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%9C%89%E5%88%AB-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">奇偶有别[记录型信号量]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%A5%87%E6%95%B0"><span class="toc-text">子程序设计[奇数]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%81%B6%E6%95%B0"><span class="toc-text">子程序设计[偶数]</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%A4%90%E9%99%90%E6%95%B0-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">进餐限数[记录型信号量]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2"><span class="toc-text">子程序设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85"><span class="toc-text">读者-写者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%8A%E5%8F%98%E9%87%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">程序信号量及变量设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-6"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">写者子程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">读者子程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E6%80%9D"><span class="toc-text">反思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-text">消除读者优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%9E%8B%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85"><span class="toc-text">公平型读者-写者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-7"><span class="toc-text">主程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">读者子程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E8%80%85%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="toc-text">写者子程序设计</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-text">存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">用户程序处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">程序处理与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%BD%A2%E6%88%90"><span class="toc-text">程序地址空间及形成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6"><span class="toc-text">内存管理逻辑部件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">内存管理模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="toc-text">操作系统概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AE%BA"><span class="toc-text">导论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INTERFACE%EF%BC%88%E6%8E%A5%E5%8F%A3%E3%80%81%E7%95%8C%E9%9D%A2%E3%80%81%E4%BB%8B%E9%9D%A2%EF%BC%89"><span class="toc-text">INTERFACE（接口、界面、介面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VIRTUAL-MACHINE"><span class="toc-text">VIRTUAL MACHINE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD"><span class="toc-text">操作系统功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6"><span class="toc-text">用户角度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A7%92%E5%BA%A6"><span class="toc-text">系统角度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">操作系统的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">计算机系统的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%EF%BC%88BOOT-SECTOR%EF%BC%89"><span class="toc-text">主引导扇区（BOOT SECTOR）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BOOTSTRAP-gt-OS%E8%87%AA%E5%B7%B1%E6%8A%8A%E8%87%AA%E5%B7%B1%E6%8B%89%E5%90%AF%E5%8A%A8"><span class="toc-text">BOOTSTRAP-&gt;OS自己把自己拉启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BOOTSTRAP-OF-COMPUTER"><span class="toc-text">BOOTSTRAP OF COMPUTER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STORAGE-SYSTEM-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">STORAGE SYSTEM(存储系统)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-x2F-O%E7%BB%93%E6%9E%84"><span class="toc-text">I&#x2F;O结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">单处理器系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">多处理器系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F"><span class="toc-text">集群系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%94%A8%E6%88%B7%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">单用户单模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">多道程序设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F"><span class="toc-text">引发的其他模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-text">操作系统提供的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#USER-INTERFACE"><span class="toc-text">USER INTERFACE</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CLI%EF%BC%88Command-Line-Interface%EF%BC%89%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89"><span class="toc-text">CLI（Command Line Interface）（命令行）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GUI-Graphic-User-Interface"><span class="toc-text">GUI(Graphic User Interface)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Batch-%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-text">Batch(批处理)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88SYSTEM-CALLS%EF%BC%89"><span class="toc-text">系统调用（SYSTEM CALLS）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">实现机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A8%A1%E5%BC%8F%EF%BC%88DUAL-MODE%EF%BC%89"><span class="toc-text">双重模式（DUAL MODE）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">进程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">程序和进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PROGRAM-COUNTER"><span class="toc-text">PROGRAM COUNTER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PROCESS-IN-MEMORY"><span class="toc-text">PROCESS IN MEMORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">并发的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%88PROCESS-STATE%EF%BC%89"><span class="toc-text">进程状态（PROCESS STATE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%A6%BB%E5%BC%80CPU"><span class="toc-text">进程何时离开CPU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">进程切换和进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF%EF%BC%88Interrupt%EF%BC%89"><span class="toc-text">中断技术（Interrupt）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90"><span class="toc-text">中断源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD%EF%BC%88interrupt%EF%BC%89"><span class="toc-text">外中断（interrupt）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD%EF%BC%88%E5%BC%82%E5%B8%B8Exception%EF%BC%89"><span class="toc-text">内中断（异常Exception）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E5%92%8C%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-text">特权指令和非特权指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-text">特权指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-text">非特权指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="toc-text">模式切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2-1"><span class="toc-text">进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-text">切换时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">切换过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%88PROCESS-SCHEDULING%EF%BC%89"><span class="toc-text">进程调度（PROCESS SCHEDULING）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0"><span class="toc-text">fork（）函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">采用多线程的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B"><span class="toc-text">多核编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">多线程模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-text">处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-text">CPU调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-text">抢占调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E7%9A%84%E8%A1%A1%E9%87%8F"><span class="toc-text">调度算法性能的衡量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">调度性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS-x2F-FIFO%EF%BC%89"><span class="toc-text">先来先服务（FCFS&#x2F;FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%BB%AD%EF%BC%89"><span class="toc-text">先来先服务（续）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">先来先服务优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%88ROUND-ROBIN%EF%BC%89"><span class="toc-text">时间片轮转（ROUND ROBIN）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RR%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">RR算法分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%88SJF%EF%BC%89"><span class="toc-text">最短作业优先（SJF）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SJF-x2F-SRTF%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">SJF&#x2F;SRTF算法分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88PRIORITY%EF%BC%89"><span class="toc-text">优先级调度（PRIORITY）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">优先级的定义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B-x2F-%E7%BA%BF%E7%A8%8B"><span class="toc-text">并发进程&#x2F;线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">并发进程之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%EF%BC%88RACE%EF%BC%89"><span class="toc-text">竞争（RACE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%EF%BC%88COOPERATION%EF%BC%89"><span class="toc-text">协作（COOPERATION）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-text">同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98%EF%BC%88CRITICAL-SECTION-PROBLEM%EF%BC%89"><span class="toc-text">临界区问题（CRITICAL-SECTION PROBLEM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%87%BA%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%8D%8F%E8%AE%AE"><span class="toc-text">进程进出临界区协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86%E5%87%86%E5%88%99"><span class="toc-text">临界区管理准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%A3%E5%86%B3%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">软件解决临界区管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MUTEX-LOCKS"><span class="toc-text">MUTEX LOCKS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">锁的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">锁的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%99%E5%BC%8F%E7%AD%89%E5%BE%85%EF%BC%88BUSY-WAITING%EF%BC%89"><span class="toc-text">忙式等待（BUSY WAITING）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">信号量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">信号量的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">信号量的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BINARY-SEMAPHORE"><span class="toc-text">BINARY SEMAPHORE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COUNTING-SEMAPHORE"><span class="toc-text">COUNTING SEMAPHORE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">同步问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">生产-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">单缓冲解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E7%95%8C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88THE-BOUNDED-BUFFER-PROBLEM%EF%BC%89"><span class="toc-text">有界缓冲区（THE BOUNDED-BUFFER PROBLEM）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%B9%E6%9E%9C%E6%A9%98%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-text">苹果橘子问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88Reader%EF%BC%8CWriter%EF%BC%89"><span class="toc-text">读者-写者问题（Reader，Writer）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rules"><span class="toc-text">Rules:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98"><span class="toc-text">理发师问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家用餐死锁问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DEADLOCK-%E5%AE%9A%E4%B9%89"><span class="toc-text">DEADLOCK(定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="toc-text">死锁与饥饿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">产生死锁的四个必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#METHONDS-FOR-HANDLING-DEADLOCKS"><span class="toc-text">METHONDS FOR HANDLING DEADLOCKS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">死锁的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%98%B2%E6%AD%A2-Prevention"><span class="toc-text">死锁的防止(Prevention)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D-Avoidance"><span class="toc-text">死锁的避免(Avoidance)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E6%81%A2%E5%A4%8D%EF%BC%88Detection-amp-Recovery%EF%BC%89"><span class="toc-text">死锁的检测和恢复（Detection&amp;Recovery）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%98%B2%E6%AD%A2"><span class="toc-text">死锁的防止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81-SAFE-STATE"><span class="toc-text">安全状态(SAFE STATE)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-text">死锁的避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">银行家算法-数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">银行家算法的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-text">死锁的检测与恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">资源分配图表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="toc-text">死锁定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-text">死锁的解除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HOW-OS-DO-TO-DEADLOCKS"><span class="toc-text">HOW OS DO TO DEADLOCKS?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">进程内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F"><span class="toc-text">进程的内存映像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MAIN-MEMORY%EF%BC%88%E4%B8%BB%E5%AD%98%EF%BC%89"><span class="toc-text">MAIN MEMORY（主存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98CACHE"><span class="toc-text">高速缓存CACHE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="toc-text">保护操作系统和用户进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%AE%E6%A0%87"><span class="toc-text">内存管理目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">地址空间和地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-text">地址转换时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6"><span class="toc-text">编译时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%97%B6"><span class="toc-text">加载时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-text">运行时</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83MMU"><span class="toc-text">内存管理单元MMU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CONTIGUOUS-MEMORY-ALLOCATION%EF%BC%88%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%89"><span class="toc-text">CONTIGUOUS MEMORY ALLOCATION（连续内存分配）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIXED-SIZED-PARTITION%EF%BC%88%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E5%88%86%E5%8C%BA%EF%BC%89"><span class="toc-text">FIXED-SIZED PARTITION（固定大小分区）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VARIABLE-PARTITION%EF%BC%88%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%EF%BC%89"><span class="toc-text">VARIABLE-PARTITION（可变分区）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">动态存储分配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-text">地址转换和保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87"><span class="toc-text">碎片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5"><span class="toc-text">分段和分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MOTIVATION"><span class="toc-text">MOTIVATION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%96%E7%95%8C"><span class="toc-text">程序员眼中的内存世界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-text">分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LOGICAL-ADDRESS%EF%BC%88%E5%88%86%E9%A1%B5%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-text">LOGICAL ADDRESS（分页的逻辑地址）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">分段和分页的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-text">页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PAGE-TABLE"><span class="toc-text">PAGE TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HARDWARE-PAGE-TABLE"><span class="toc-text">HARDWARE PAGE TABLE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLB%EF%BC%88%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%EF%BC%89"><span class="toc-text">TLB（是一个硬件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLB-HIT-RATIO%EF%BC%88%E5%91%BD%E4%B8%AD%E7%8E%87%EF%BC%89"><span class="toc-text">TLB HIT RATIO（命中率）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-text">保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B5"><span class="toc-text">页表页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-text">修改缓存数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0"><span class="toc-text">缓存数据的淘汰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E8%A3%85%E5%85%A5%E5%92%8C%E9%83%A8%E5%88%86%E5%AF%B9%E6%8D%A2"><span class="toc-text">部分装入和部分对换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VIRTUAL-MEMORY%EF%BC%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-text">VIRTUAL MEMORY（虚拟内存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DEMAND-PAGING%EF%BC%88%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%EF%BC%89"><span class="toc-text">DEMAND PAGING（请求调页）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E6%AD%A5%E9%AA%A4"><span class="toc-text">请求调页步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">请求调页的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-text">页面置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">页面置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FIFO"><span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OPTIMAL%EF%BC%88%E6%9C%80%E4%BC%98%EF%BC%89"><span class="toc-text">OPTIMAL（最优）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU-LEAST-RECENT-UNUSED%EF%BC%89"><span class="toc-text">LRU (LEAST RECENT UNUSED）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#THRASHING%EF%BC%88%E6%8A%96%E5%8A%A8%EF%BC%89"><span class="toc-text">THRASHING（抖动）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">抖动的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PAGE-FAULT-FREQUENCY"><span class="toc-text">PAGE FAULT FREQUENCY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CONCLUDING-REMARKS"><span class="toc-text">CONCLUDING REMARKS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8"><span class="toc-text">大容量存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">磁盘格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">磁盘性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DISK-I-x2F-O-REQUEST"><span class="toc-text">DISK I&#x2F;O REQUEST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DISK-SCHEDULING%EF%BC%88%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-text">DISK SCHEDULING（磁盘调度）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FCFS-SCHEDULING"><span class="toc-text">FCFS SCHEDULING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSTF-SCHEDULING%EF%BC%88Shortest-Seek-Time-First-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">SSTF SCHEDULING（Shortest-Seek-Time First 最短寻道时间优先)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCAN-SCHEDULING%EF%BC%88%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">SCAN SCHEDULING（扫描算法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-SCAN-SCHEDULING%EF%BC%88%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">C-SCAN SCHEDULING（循环扫描算法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LOOK-SCHEDULING%EF%BC%88%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">LOOK SCHEDULING（电梯算法）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECTION-OF-A-ALGORITHM"><span class="toc-text">SELECTION OF A ALGORITHM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LINUX-IO-SCHEDULER"><span class="toc-text">LINUX IO SCHEDULER</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Wzq</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//at.alicdn.com/t/c/font_4021291_6aqa19wwunx.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/Java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 Java教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/Hexo/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 Hexo教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C++教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/Python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 Python教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📙 SSM教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://pigwzq.github.io/categories/编辑器/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍎 编辑器教程 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://pigwzq.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #8bf306}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" href="categories/C/">C++</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">C++</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" href="categories/Hexo/">Hexo</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Hexo</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_45.webp);"> <a class="categoryBar-list-link" href="categories/Java/">Java</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Java</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/202304202204885.png);"> <a class="categoryBar-list-link" href="categories/SSM/">SSM</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Python</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/p3.jpg);"> <a class="categoryBar-list-link" href="categories/Python/">Python</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">SSM</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.staticaly.com/gh/pigWzq/markdown_pic@main/2023/4/p1.jpg);"> <a class="categoryBar-list-link" href="categories/编辑器/">编辑器</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">编辑器</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/编辑器/vscode/">vscode</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/C/">C#</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/计组/">计组</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/数据库原理/">数据库原理</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/javaEE/">javaEE</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/编辑器/idea/">idea</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法/">算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/计网/">计网</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法/排序/">排序</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/09/23/2023-9-23-计算机网络/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" href="2023/09/23/2023-9-23-计算机网络/" alt="">计算机网络</a><div class="blog-slider__text">计网</div><a class="blog-slider__button" href="2023/09/23/2023-9-23-计算机网络/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/05/29/2023-5-29-javaEE/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-29</span><a class="blog-slider__title" href="2023/05/29/2023-5-29-javaEE/" alt="">javaEE</a><div class="blog-slider__text">javaEE笔记</div><a class="blog-slider__button" href="2023/05/29/2023-5-29-javaEE/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/05/24/2023-5-24-数据库原理/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-24</span><a class="blog-slider__title" href="2023/05/24/2023-5-24-数据库原理/" alt="">数据库原理</a><div class="blog-slider__text">数据库原理笔记</div><a class="blog-slider__button" href="2023/05/24/2023-5-24-数据库原理/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/05/14/2023-5-14-C/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-14</span><a class="blog-slider__title" href="2023/05/14/2023-5-14-C/" alt="">C#</a><div class="blog-slider__text">C#笔记</div><a class="blog-slider__button" href="2023/05/14/2023-5-14-C/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/05/07/2023-5-7-算法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-07</span><a class="blog-slider__title" href="2023/05/07/2023-5-7-算法/" alt="">算法</a><div class="blog-slider__text">算法笔记</div><a class="blog-slider__button" href="2023/05/07/2023-5-7-算法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/23/2023-4-21-计组/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-23</span><a class="blog-slider__title" href="2023/04/23/2023-4-21-计组/" alt="">计算机组成原理</a><div class="blog-slider__text">计组笔记</div><a class="blog-slider__button" href="2023/04/23/2023-4-21-计组/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/20/2023-5-29-编辑器/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-20</span><a class="blog-slider__title" href="2023/04/20/2023-5-29-编辑器/" alt="">编辑器</a><div class="blog-slider__text">编辑器的学习</div><a class="blog-slider__button" href="2023/04/20/2023-5-29-编辑器/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/20/2023-4-20-编辑器/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-20</span><a class="blog-slider__title" href="2023/04/20/2023-4-20-编辑器/" alt="">编辑器</a><div class="blog-slider__text">编辑器的学习</div><a class="blog-slider__button" href="2023/04/20/2023-4-20-编辑器/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/20/2023-4-20-SSM/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-20</span><a class="blog-slider__title" href="2023/04/20/2023-4-20-SSM/" alt="">SSM的学习</a><div class="blog-slider__text">SSM笔记</div><a class="blog-slider__button" href="2023/04/20/2023-4-20-SSM/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/10/2023-4-13-Python/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-10</span><a class="blog-slider__title" href="2023/04/10/2023-4-13-Python/" alt="">第四篇文章</a><div class="blog-slider__text">这是第四篇文章</div><a class="blog-slider__button" href="2023/04/10/2023-4-13-Python/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/10/2023-4-13-Java/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_2.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-10</span><a class="blog-slider__title" href="2023/04/10/2023-4-13-Java/" alt="">第一篇文章</a><div class="blog-slider__text">这是第一篇文章</div><a class="blog-slider__button" href="2023/04/10/2023-4-13-Java/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/10/2023-4-13-C/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_2.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-10</span><a class="blog-slider__title" href="2023/04/10/2023-4-13-C/" alt="">第三篇文章</a><div class="blog-slider__text">这是第三篇文章</div><a class="blog-slider__button" href="2023/04/10/2023-4-13-C/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/04/10/2023-4-13-Hexo/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_8.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-10</span><a class="blog-slider__title" href="2023/04/10/2023-4-13-Hexo/" alt="">第二篇文章</a><div class="blog-slider__text">这是第二篇文章</div><a class="blog-slider__button" href="2023/04/10/2023-4-13-Hexo/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?pigWzq",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'pigWzq')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>